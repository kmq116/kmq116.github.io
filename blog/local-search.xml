<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于我写的东西</title>
    <link href="/blog/2023/04/11/my-reflection/"/>
    <url>/blog/2023/04/11/my-reflection/</url>
    
    <content type="html"><![CDATA[<p>现在回过头，来看自己以前写过的文章，其实是没有什么技术含量的，充其量被称作个人学习笔记，哪怕自己回过头来看，也并不能给自己带来对某个技术特别深刻的见解<br>我对自己之前的评价是，小打小闹</p><p>看着网上各位前辈，同龄人，比我还小的人，人均开源社区混的不错，github 瓷砖贴的绿油油</p><p>看看自己写的小 demo，什么小菜鸡？<br><del>话说，hexo 插入本地图片是真的难用，垃圾</del>  </p><img src="/blog/2023/04/11/my-reflection/articles.png" class=""><p>不过反过来想想，能意识到自己之前写的东西 low 应该是一件好事</p><p>至少说明自己成长了</p><p>换个思路，博客只能记录编程学习吗？我觉得并不是，记录下生活，感悟，心得其实也很好</p><p>想提升自己的码力，最好扎进开源社区，学好英语才是重中之重</p><p>综上所述，之前写的文章，可耻的匿了，就留个年终总结吧！！！</p><p>好好沉淀自己,待我有足够能力输出干货技术文章时，再来写点什么。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023 新年计划</title>
    <link href="/blog/2023/02/15/2023%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    <url>/blog/2023/02/15/2023%E5%B9%B4%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>互联网寒冬来喽，今年要学习  </p><p>首先把去年没看完的 《vue3 设计与实现》先看完–成果：把 vue 源码撸一遍，造一个真正完整可用的轮子  </p><p>学一门不同于 js 的市场上的实用语言–成果：用该语言写后台程序  </p><p>学 csapp 这本书–成果：尽量多看吧，多了解，多思考  </p><p>自考这东西也要搞起来，毕竟这个纯自学还是会有一定收获的–成果：报考考试，考过  </p><p>把后端那一套服务器相关的东西学会–成果：希望后端下次再说刀客，linux 一大堆东西的时候，我能完全听懂  </p><p>其余夯实 js 的小细节，学习 ts –成果：这个不需要解释，基础不牢，地动山摇  </p><p>贪多嚼不烂，就这些</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>一定要夯实计算机科学的基础知识，虽然我资质尚浅，但是我坚定的认为，是否夯实基础一定会影响我未来发展的天花板  </p><p>关于找工作，尝试在网上写写真正有技术含量的文章，在互联网增加曝光度，或许能让我有那么一点点内推的机会（过不过另说，起码能面试  </p><p>另外，谭光志，霍春阳等超级多业界前辈，都是我的榜样，向他们学习，争取三年之内赶上他们一半强（逃</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2022 年终总结</title>
    <link href="/blog/2023/02/15/22-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2023/02/15/22-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="一篇迟来的年终总结"><a href="#一篇迟来的年终总结" class="headerlink" title="一篇迟来的年终总结"></a>一篇迟来的年终总结</h3><h4 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h4><p>今年总归是学习少了，原因是跟同事之间打游戏，打的比较 high  </p><p>毕竟找到了玩游戏的最高配置，就是有朋友一起玩  </p><p>相比较 2021 年，花在代码上的时间，下班修炼自己的时间变得非常少，可以说基本没有  </p><p>中间看了霍春阳写的 《vue3 设计与实现》和 vue 渲染器的系列文章，但是也没看完  </p><p>然后就是一些零零散散的学习了一些 ts 骚操作， git 骚操作，程度到什么样子呢，就是用来工作，绰绰有余的程度  </p><p>再就是对公司的业务也更加熟练了  </p><h4 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h4><p>工作上，虽然自己岗位是前端，但是因为跨端搞安卓，接触到了超级多的 sqlite 操作，写了不少的 sql，程度是把后端同学的逻辑在安卓段里完整的实现了一遍，收获则是完整的理解了公司的业务到底是怎么运作的  </p><p>再就是平时私下里会跟同事聊公司靠什么赚钱，公司各部门之间是怎么沟通等等，久而久之对公司整体运作也有了大概的了解，至于这个有什么用，可能别人问起来的时候，我可以说一说公司是做 xxx，卖 xxx，我的工作就是跟这个相关的，而不是别人一问起来，就只能说，我平时画画页面（虽然就是个画页面的  </p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我的性格属于那种一旦对什么事情感兴趣就回去疯狂的做，直到干腻了，干烦了，就慢慢不那么热情了，今年游戏玩了几个月之后，突然间就进入了贤者模式，偶尔开一下，上个号，打一把，就这样子</p><p>还好在编程上，我性格的这个特点并不适用，但是自己深切的感受到了现在自己处在舒适区，学的东西够用，对业务也能理清理顺，也就不逼迫自己去学习了  </p><p>下了班还是要继续进步的，我一个臭大专，指不定哪天就失业了，那时候，靠自己手头攒的钱能活多久呢？</p><p>开卷有益（卷自己</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>互联网行业的薪资水平跟个人实力有一定关系，但这个关系只占一小部分，其他的都是市场决定的，市场有需求，需求量大，待遇就会上去，等到市场饱和，薪资待遇也就那样子了  </p><h3 id="时刻保持清醒，不要浮躁，不要飘"><a href="#时刻保持清醒，不要浮躁，不要飘" class="headerlink" title="时刻保持清醒，不要浮躁，不要飘"></a>时刻保持清醒，不要浮躁，不要飘</h3><p>总之，市场决定待遇  </p><p>确实感觉到了互联网的寒冬，愿在这个寒冬先苟活住吧，下篇是 23 年计划</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2021 年终总结</title>
    <link href="/blog/2022/01/02/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2022/01/02/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="个人方面"><a href="#个人方面" class="headerlink" title="个人方面"></a>个人方面</h3><p>这一年 Blog 内容理应多很多东西的，但是在自己的编程水平提高的同时，边写边删除了大部分的文章  </p><p>被删除的文章标题大致如下  </p><ul><li><p>《nodejs 连接 mysql 实现增删改查》- 刚刚接触用 node 写增删改查的水文  </p></li><li><p>《数组拍平》- 看到 mdn Array 的 flat api，并且用原生写法仿写了一下  </p></li><li><p>《vuex 学习》- 对着官网抄抄用法，记了一堆流水账  </p></li><li><p>《node websocket》- 写了个 websocket 的用法记录  </p></li><li><p>《this》- 对着书上介绍的 this 用法指向抄抄  </p></li></ul><ul><li>《写业务代码要注意的》- 这个还算比较有意思，从 git<br>记录里翻出了这么一段，当时写这个是很多需求都是以前没有做过的（毕竟上家公司只做过表单业务），然后到了这里，面对这些不容易，对我而言陌生的需求，我感觉压力山大，大概入职两个月的时候写了这个东西，现在看来当时真的是有心了，竟然有这种小总结</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-section">### 写业务代码前的思考</span><br><br><span class="hljs-bullet">-</span> 在写一个复杂需求的时候，一定一定要进行一个总体的分析<br><span class="hljs-bullet">    -</span> 需求的分析，这个大需求里面的小需求是什么<br><span class="hljs-bullet">    -</span> 在做每一个需求的时可能会遇到什么技术难点，有没有解决的办法，这里是查阅资料的阶段<br><span class="hljs-bullet">    -</span> 有些需求的实现页没必要想得太复杂，找好相关技术的文档，一步步的看，从 demo 开始，只要这个技术的文档写的没有问题，最后都可以出货<br><span class="hljs-bullet">    -</span> 细节的处理，有一些细节需要自己去考虑，比如对用户使用是否友好，是不是符合用户的实际使用<br><span class="hljs-bullet">-</span> 总之在写代码之前不要盲目，一定要做好前期的规划，想好了，梳理顺了再去进行编写代码，在代码编写的过程中，也要注意代码的质量，风格，规范等，以及遵从软件工程的原则，写出高可读性，高可维护性的代码<br><span class="hljs-bullet">-</span> 改 bug 的时候也要像看开源项目源码一样，从宏观到微观，不然解决问题的思路都是错误的<br></code></pre></td></tr></table></figure><ul><li><p>《重构》- 读了 《重构》这本书后抄了一些书中的代码，假装自己学会了😊  </p></li><li><p>《跟着 jquery 学正则》- 在尝试看 jquery 源代码的时候把正则表达式学习了一下，然而最后对源码的阅读进度在 jquery 的无 new 构建上止步  </p></li><li><p>《前端编译原理 the super tiny compiler》- 第一次接触到前端编译原理，了解到 ast、parser 等概念，记得这个 200 行的小项目我看了三四天  </p></li></ul><p>总之就是，今年写的这种文章，现在回过头看，虽然觉得很水很幼稚，但是在这个过程中，解决问题的能力越来越强了  </p><p>期间读 <a href="https://antfu.me/posts/about-yak-shaving-zh">关于 Yak Shaving</a> 这篇文章给我的启发很大，里面有提到</p><blockquote><p>Yak Shaving 的字面意思是为剪牦牛毛，而引申出来的意思是，当你在进行一个工作时，发现另一个工作还没有完成，你便先去解决那个工作，在进行那个工作时，你又发现另一个工作… 如此往复，让你偏离了原本本该完成的工作，最终却也什么都没有完成。</p></blockquote><p>在其他领域可能这样做会导致没什么成果，但是在编程这个领域，这样做得结果就是在不断学习的过程中，解决问题的能力，各种技能也都会得到提升。</p><h3 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h3><p>今年因为项目一直在维护，确实见识到了什么叫代码的脏乱差<br>也让我的内心更加确定了，编程这东西实力与工作经验完全不是强相关<br>发现了每个人都有自己擅长的东西和不擅长的东西  </p><p>毕业这一年半以来，最明显的就是自己的棱角被磨平了好多，没有了在校时的狂气（指在校期间总觉得就业很简单，结果差点失业），可能这就是社会大学对每个人的磨练吧  </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>给 uniapp 提了一个 pr ，bug 并不难修复，难的是我将项目拉下来并且跑起来，最后定位到 bug 所在的过程。这个调试的过程对我而言是一段痛并快乐的经历</li><li>给 windicss 翻译了 3-4 篇文档，做出了一点贡献，在参与这个项目的过程中，学会了开源的协作方式  </li><li>英语水平有了显著提高，可以较为流畅得阅读一些英文文档，学会了用英文搜索自己遇到的问题（善用英文搜索，利好你我他，大多数问题分分钟解决）  </li></ul><blockquote><p>思考：每每我在英文环境下找到自己问题的答案的时候，就会对国内的互联网环境感到悲哀，这么多年你抄我我抄你，不断的向技术圈排泄各种垃圾<br>一些爬虫甚至都已经爬一些墙外网站然后翻译（机翻）到国内，每次打开这种搜索结果，都会被恶心到  </p></blockquote><h3 id="展望一下-2022"><a href="#展望一下-2022" class="headerlink" title="展望一下 2022"></a>展望一下 2022</h3><p>英语还是要继续学习的，不为别的，就为了能读上第一手英文文档，能对开源社区多做一些贡献  😜  </p><p>日语出于兴趣也会持续学习的 😉</p><p>保持学习，好好生活，热爱生活，少比较，少焦虑，降低期望，提高幸福感，少熬夜，不遗憾过去，展望未来 🤪</p><p>只能这样子加加油，打打气了，不管咋样，生活还是要继续的不是吗 💕💕💕💕</p>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅浅浅尝编译原理 the-super-tiny-compiler</title>
    <link href="/blog/2021/10/04/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86the-super-tiny-compiler/"/>
    <url>/blog/2021/10/04/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86the-super-tiny-compiler/</url>
    
    <content type="html"><![CDATA[<h3 id="时隔四个月的更新"><a href="#时隔四个月的更新" class="headerlink" title="时隔四个月的更新"></a>时隔四个月的更新</h3><p>其实后面的递归步骤只是借助 JS 的引用数据类型特性，模拟了类似 c 语言的指针功能 😐 ,就是简单的传递指针，不断生成类似链表的数据结构，填充数据，最终得到目标代码…而已..已.</p><h3 id="起初"><a href="#起初" class="headerlink" title="起初"></a>起初</h3><p>the-super-tiny-compiler 是 github 上的一个使用 js 编写的编译器，代码注释中称其可能是最小的编译器，可以将 lisp 风格的语言编写为 c 风格的语言   </p><p>这个编译器项目可以说是麻雀虽小，五脏俱全</p><p>但是本人再阅读器源代码的时候，在生成新 ast 的过程中，对其递归过程产生了不解  </p><p>所以从现在开始，要对源代码进行一下分析  </p><p>编译器原理简单来说就是<br>词法分析<br>语法分析（生成 ast）<br>将 oldAst -&gt; newAst<br>最后将产生的 newAst 生成目标语言语法进行输出<br>将 <code>(add 2 (subtract 4 2))</code> 作为输入，得到的 ast 结构如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ast = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>  <span class="hljs-attr">body</span>: [<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CallExpression&quot;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;add&quot;</span>,<br>      <span class="hljs-attr">params</span>: [<br>        &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>          <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CallExpression&quot;</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;subtract&quot;</span>,<br>          <span class="hljs-attr">params</span>: [<br>            &#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>              <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;4&quot;</span>,<br>            &#125;,<br>            &#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>              <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>            &#125;,<br>          ],<br>        &#125;,<br>      ],<br>    &#125;,<br>  ],<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>得到这个结构后，执行了这样一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span>(<span class="hljs-params">ast</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> newAst = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>    <span class="hljs-attr">body</span>: []<br>  &#125;<br><br>  ast._context = newAst.body<br>&#125;<br></code></pre></td></tr></table></figure><p>给 ast 对象下添加了一个新属性，将该属性指向了 newAst 的 body 属性中<br>然后向下执行了 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span>(<span class="hljs-params">ast</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> newAst = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>    <span class="hljs-attr">body</span>: []<br>  &#125;<br><br><span class="hljs-comment">// 这里改变 ast 的属性就可以之间影响到 newAst </span><br>  ast._context = newAst.body<br><br>  traverser(ast, &#123;<br>    <span class="hljs-comment">// 处理数字</span><br>    <span class="hljs-attr">NumberLiteral</span>: &#123;<br>      <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">node, parent</span>)</span> &#123;<br>        parent._context.push(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NumberLiteral&#x27;</span>,<br>          <span class="hljs-attr">value</span>: node.value<br>        &#125;)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 字符串</span><br>    <span class="hljs-attr">StringLiteral</span>: &#123;<br>      <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">node, parent</span>)</span> &#123;<br>        parent._context.push(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;StringLiteral&#x27;</span>,<br>          <span class="hljs-attr">value</span>: node.value,<br>        &#125;);<br>      &#125;,<br>    &#125;,<br><br>    <span class="hljs-attr">CallExpression</span>: &#123;<br>      <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">node, parent</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> expression = &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,<br>          <span class="hljs-attr">callee</span>: &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,<br>            <span class="hljs-attr">name</span>: node.name<br>          &#125;,<br>          <span class="hljs-attr">arguments</span>: []<br>        &#125;<br><br>        node._context = expression.arguments;<br><br>        <span class="hljs-keyword">if</span> (parent.type !== <span class="hljs-string">&quot;CallExpression&quot;</span>) &#123;<br>          expression = &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ExpressionStatement&#x27;</span>,<span class="hljs-comment">//表达式语句</span><br>            expression<br>          &#125;<br>        &#125;<br><br>        parent._context.push(expression)<br>      &#125;<br>    &#125;<br><br><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> newAst<span class="hljs-comment">//返回 newAst</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，newAst 的数据变化只执行了一个 traverser 函数就完成了，函数把刚刚的 ast 当作参数，以及根据不同类型对 newAst 中的 body 复制的行为,</p><p>这个函数的内部是这样子的 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverser</span>(<span class="hljs-params">ast, visitor</span>) </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseArray</span>(<span class="hljs-params">array, parent</span>) </span>&#123;<br>    <br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseNode</span>(<span class="hljs-params">node, parent</span>) </span>&#123;<br>    <span class="hljs-comment">// 判断传入进来的 node 有没有对应的属性</span><br>    <span class="hljs-keyword">let</span> methods = visitor[node.type]<br><br>    <span class="hljs-comment">// 如果有 就给其父节点的 body 赋值进去</span><br>    <span class="hljs-keyword">if</span> (methods &amp;&amp; methods.enter) &#123;<br>      methods.enter(node, parent)<br>    &#125;<br><br>    <span class="hljs-comment">// 然后再把 visiter 中不包括的属性进行单独处理 </span><br>    <span class="hljs-keyword">switch</span> (node.type) &#123;<br>      <span class="hljs-comment">// first exec 执行最外层的 遍历 节点下的 body</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Program&quot;</span>:<br>        traverseArray(node.body, node);<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;CallExpression&quot;</span>:<br>        traverseArray(node.params, node)<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;NumberLiteral&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;StringLiteral&quot;</span>:<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(node.type)<br>    &#125;<br>  &#125;<br><br>  traverseNode(ast, <span class="hljs-literal">null</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行他的时候，主线为 traverser -&gt; traverseNode -&gt;<br>ast 作为 node 参数传入进去，这个函数的执行过程就进行了递归调用<br>第一次执行  methods 为 undefined  然后进入 switch 语句中<br>第一次的 ast type 是 Program 然后就将 ast 的 body 当作参数传递进去，然后 break;掉<br>至此，函数主线已经执行完毕了<br>之后的执行流程则是对 ast.body 进行的一个伪递归或者叫嵌套调用，函数每次根据其传入的 tree 参数，根据表达式，参数，去判断是否生成新的 ast </p><p>值得一提的是，在生成 newAst 的时候<br>有类似这样的语句<br><code> node._context = expression.arguments;</code><br>将传入节点的_context 属性指向当前对象下的某个属性，达到引用的效果，这时，使用 visitor 遍历语法数的时候，不管传入的对象是什么，因为已经在上层构建好了内存地址的引用关系，所以只需要给 parent._context 属性添加只就可以了   </p><p>最后的最后就是将生成的新 ast 生成我们的目标语言，这个没什么好说的，递归生成字符串就好了。</p><p>总结，看似简单的小项目，如果自己去实现，不知到要考虑多少细节，所以说，前端深入之路，任重而道远！</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
