<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>现在状态以及未来规划</title>
    <link href="/blog/2022/06/08/%E7%8E%B0%E5%9C%A8%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92/"/>
    <url>/blog/2022/06/08/%E7%8E%B0%E5%9C%A8%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>现在对自己的评价是，前端基础尚可，属于前端终极熟练工，能够自己独立完成任务的同时，还能给予开发组内人员帮助，解决各种疑难杂症也不会有太大障碍<br>对自己常用的技术非常之熟练，对于这些技术的实现也有所了解，不了解的也能猜个七七八八<br>遇到的障碍感觉是思想层面的，感觉要做一些思想上的转变，比如站在更高的维度看问题  </p><h3 id="办法"><a href="#办法" class="headerlink" title="办法"></a>办法</h3><p>想办法开拓自己的眼界<br>技术上夯实基础，补充计算机的基础知识<br>补充 JS 中的技术细节，比如各种手写（感觉收益不大）<br>看技术书籍，《重构》等书籍<br>保持自己的竞争力，比如算法题，面经这种偏八股的<br>每天下班后或者周末空余时间写自己的代码，保持 github 高活跃<br>积极参与到社区的开源中去</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>感觉现在要稍稍跳出前端这块，在保持学习前端知识的同时，对其他东西做一些延展，比如服务端等等等等</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重学两数之和</title>
    <link href="/blog/2022/04/20/%E9%87%8D%E5%AD%A6%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/blog/2022/04/20/%E9%87%8D%E5%AD%A6%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>记得接触到的第一道算法题就是 twoSum ，至今还记得第一次做抓耳挠腮的恨得牙痒痒都没思路的 那个感觉</p><p>解法：</p><ol><li>暴力解法，没有有什么好说的 ，指的注意的就是 j 从 i + 1 开始，可以一定程度上减少遍历次数，时间复杂度 O(n^2)，空间复杂度 O(1)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) &#123;<br>                <span class="hljs-keyword">return</span> [i, j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 优化 内部循环可以使用双指针 内部两个指针一个从前往后找，一个从后往前找</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums: number[], target: number</span>): number[] &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> x = nums[i]<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &lt;= k; j++, k--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] === target - x) &#123;<br>                <span class="hljs-keyword">return</span> [i, j]<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[k] === target - x) &#123;<br>                <span class="hljs-keyword">return</span> [i, k]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>hash table 解法</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">const</span> length = nums.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(target - nums[i])) &#123;<br>            <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(target - nums[i]), i]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(nums[i], i)<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>hash table 解法是遍历数组时构建 hash 表，然后遍历 hash 表，如果 hash 表中有 target - nums[i] 则返回，否则添加到 hash 表中，时间复杂度 O(n)，空间复杂度 O(n)</p><ol start="3"><li>双指针 + hash 表 解法</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">const</span> length = nums.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = length - <span class="hljs-number">1</span>; i &lt;= j; i++, j--) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) <span class="hljs-keyword">return</span> [i, j]<br><br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(target - nums[i])) &#123;<br>            <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(target - nums[i]), i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(target - nums[j])) &#123;<br>            <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(target - nums[j]), j]<br>        &#125;<br>        map.<span class="hljs-title function_">set</span>(nums[i], i)<br>        map.<span class="hljs-title function_">set</span>(nums[j], j)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>外侧 for 循环时从两端向中间遍历，随遍历建立 hash table ，降低了时间复杂度 O(n/2)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue 源码</title>
    <link href="/blog/2022/04/03/vue%20%E6%BA%90%E7%A0%81/vue-%E6%BA%90%E7%A0%81/"/>
    <url>/blog/2022/04/03/vue%20%E6%BA%90%E7%A0%81/vue-%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/column/c_1503887097446068224">文章写在知乎上了</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跟着 vue 学代码</title>
    <link href="/blog/2022/03/04/%E8%B7%9F%E7%9D%80-vue-%E5%AD%A6%E4%BB%A3%E7%A0%81/"/>
    <url>/blog/2022/03/04/%E8%B7%9F%E7%9D%80-vue-%E5%AD%A6%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">《函数式编程指北》</a></p><h3 id="makeMap-函数"><a href="#makeMap-函数" class="headerlink" title="makeMap 函数"></a>makeMap 函数</h3><p>因为一直对函数式编程比较感兴趣，刚好在 vue 的功能函数中看到了好的范例</p><p>在 new Vue 的初始化过程中，有一段代码是检测组件名是否合法的，规则是不能使用 html 内置标签和 vue 的内置组件名，看到这段代码的时候，觉得好优雅</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> isBuiltInTag = <span class="hljs-title function_">makeMap</span>(<span class="hljs-string">&#x27;slot,component&#x27;</span>, <span class="hljs-literal">true</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeMap</span> (<br>  <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span>,<br>  expectsLowerCase?: <span class="hljs-built_in">boolean</span><br>): <span class="hljs-function">(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">string</span>[] = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; list.<span class="hljs-property">length</span>; i++) &#123;<br>    map[list[i]] = <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> expectsLowerCase<br>    ? <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> map[val.<span class="hljs-title function_">toLowerCase</span>()]<br>    : <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> map[val]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次代码优化</title>
    <link href="/blog/2022/01/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <url>/blog/2022/01/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="代码优化记录"><a href="#代码优化记录" class="headerlink" title="代码优化记录"></a>代码优化记录</h3><p>首先先说需求:<br>平台：安卓 app<br>功能：使用 sqlite 将数据存储到移动设备上，数据来源为线上接口  </p><p>需求：  </p><ul><li>第一次从线上接口请求数据，拿到所有数据并存储</li><li>除第一次之外，后面再次调用接口查询数据是否有更新  </li><li>更新的数据分为有新增的数据条目和已存储过的数据更新  </li></ul><h3 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h3><p>第一次新增的数据需求很容易，就是查到所有数据，然后将多条数据合并成一条数据就可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sql = data.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> acc + <span class="hljs-string">`(&#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27;, &#x27;<span class="hljs-subst">$&#123;cur.pid&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;cur.pids&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;time&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;time&#125;</span>&#x27;),`</span>;<br>    &#125;, <span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><p>然后是更新，更新的代码，我当时的思路是，先查询给的数据，然后找出 待更新的 和 新增的 两个数组，对两个数组进分别操作，执行完毕 over, 嗯，想法是很好，然后代码写出来是这个样子的  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//更新单位数据库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!data || !data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;没有需要更新的东西&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data, <span class="hljs-string">&#x27;待更新数据&#x27;</span>);<br>    <span class="hljs-keyword">let</span> updateNameSql = <span class="hljs-string">``</span>,<br>      updateTimeSql = <span class="hljs-string">``</span>;<br>    <span class="hljs-keyword">const</span> waitAddedList = [];<br>    <span class="hljs-keyword">const</span> unitList = &#123;&#125;,<br>      idRangeList = [];<br>    <span class="hljs-comment">//查询所有单位</span><br>    <span class="hljs-title function_">getAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (allUnitList) =&gt; &#123;<br>      allUnitList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (unitList[item.<span class="hljs-property">id</span>] = item.<span class="hljs-property">id</span>));<br><br>      data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">insertData</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果存在数据 拼接更新语句 不存在则拼接新增语句</span><br>        <span class="hljs-keyword">if</span> (unitList[insertData.<span class="hljs-property">id</span>]) &#123;<br>          idRangeList.<span class="hljs-title function_">push</span>(insertData.<span class="hljs-property">id</span>);<br>          updateNameSql += <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;insertData.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;insertData.name&#125;</span>&#x27; `</span>;<br>          updateTimeSql += <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;insertData.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          waitAddedList.<span class="hljs-title function_">push</span>(insertData);<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;查询出来的待添加的数据&#x27;</span>, waitAddedList);<br>        &#125;<br>      &#125;);<br><br>      <span class="hljs-comment">//  有待新增的数据新增</span><br>      <span class="hljs-keyword">if</span> (waitAddedList.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-title function_">add</span>(waitAddedList);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;更新的时候添加新数据失败了&#x27;</span>, e);<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//有待更新的数据更新</span><br>      <span class="hljs-keyword">if</span> (idRangeList.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">await</span> sqlite.<span class="hljs-title function_">executeSql</span>(<br>            <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;updateNameSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;updateTimeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList</span></span><br><span class="hljs-subst"><span class="hljs-string">              .join(<span class="hljs-string">&#x27;,&#x27;</span>)</span></span><br><span class="hljs-subst"><span class="hljs-string">              .slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)&#125;</span>)`</span>,<br>          );<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e, <span class="hljs-string">&#x27;更新数据出错&#x27;</span>);<br>        &#125;<br>      &#125;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;添加和更新操作完成!!!!!!&#x27;</span>);<br>    &#125;);<br>  &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当时写完了，我内心 os：这 tm 写的是啥，什么鬼东西，初学者也写不出这样的代码吧，这代码看起来好恶心啊，面条代码也不过如此吧  </p><blockquote><p>《重构》中提到:<br>优化思路是优先提高可读性和可维护性，然后再去考虑性能问题</p></blockquote><p>遵从这个原则，开搞</p><h3 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h3><p>既然可读性要高的话，那高阶函数走起来，函数式搞起来，虽然 js 的函数式不是惰性求值的  </p><p>首先不用 forEach 去取两个待更新的列表，之前 forEach 里的 if else 太丑了，顺带改了个变量名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// data.forEach((insertData) =&gt; &#123;</span><br><span class="hljs-comment">//   // 如果存在数据 拼接更新语句 不存在则拼接新增语句</span><br><span class="hljs-comment">//   if (unitList[insertData.id]) &#123;</span><br><span class="hljs-comment">//     idRangeList.push(insertData.id);</span><br><span class="hljs-comment">//     updateNameSql += `WHEN &#x27;$&#123;insertData.id&#125;&#x27; THEN &#x27;$&#123;insertData.name&#125;&#x27; `;</span><br><span class="hljs-comment">//     updateTimeSql += `WHEN &#x27;$&#123;insertData.id&#125;&#x27; THEN &#x27;$&#123;Date.now()&#125;&#x27; `;</span><br><span class="hljs-comment">//   &#125; else &#123;</span><br><span class="hljs-comment">//     waitAddedList.push(insertData);</span><br><span class="hljs-comment">//     console.error(&#x27;查询出来的待添加的数据&#x27;, waitAddedList);</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><span class="hljs-comment">// 筛选出待添加和待更新的数据</span><br><span class="hljs-keyword">const</span> addList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !unitList[item.<span class="hljs-property">id</span>]);<br><span class="hljs-keyword">const</span> updateList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>]);<br><span class="hljs-comment">// 以及待更新 id 集合</span><br>data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>] &amp;&amp; idRangeList.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>));<br></code></pre></td></tr></table></figure><p>然后是拼接 sql 语句的地方，在我改得时候需求还加了两个新字段  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 拼接更新字段的 sql</span><br><span class="hljs-keyword">const</span> nameSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> timeSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> delSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> sortSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> totalSql = <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;nameSql&#125;</span> END,sort = CASE _id <span class="hljs-subst">$&#123;sortSql&#125;</span> END,delFlag = CASE _id <span class="hljs-subst">$&#123;delSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;timeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList.join(</span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-string">&#x27;,&#x27;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">)&#125;</span>)`</span>;<br></code></pre></td></tr></table></figure><p>处理完两个列表和 sql 语句之后，执行下面的逻辑，选择了 Promise.allSettled 处理未知数量的 promise，取得其返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  有待新增的数据新增</span><br><span class="hljs-comment">// if (waitAddedList.length) &#123;</span><br><span class="hljs-comment">// try &#123;</span><br><span class="hljs-comment">//   await add(waitAddedList);</span><br><span class="hljs-comment">// &#125; catch (e) &#123;</span><br><span class="hljs-comment">//   console.error(&#x27;更新的时候添加新数据失败了&#x27;, e);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// //有待更新的数据更新</span><br><span class="hljs-comment">// if (idRangeList.length) &#123;</span><br><span class="hljs-comment">// try &#123;</span><br><span class="hljs-comment">//   await sqlite.executeSql(</span><br><span class="hljs-comment">//     `UPDATE unit_info SET name = CASE _id $&#123;updateNameSql&#125; END,updateTime = CASE _id $&#123;updateTimeSql&#125; END WHERE _id in ($&#123;idRangeList</span><br><span class="hljs-comment">//       .join(&#x27;,&#x27;)</span><br><span class="hljs-comment">//       .slice(0, -1)&#125;)`,</span><br><span class="hljs-comment">//   );</span><br><span class="hljs-comment">// &#125; catch (e) &#123;</span><br><span class="hljs-comment">//   console.error(e, &#x27;更新数据出错&#x27;);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> pTasks = [];<br><span class="hljs-keyword">if</span> (addList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">add</span>(addList));<br><span class="hljs-keyword">if</span> (updateList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(sqlite.<span class="hljs-title function_">executeSql</span>(totalSql));<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(pTasks)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resList</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resList);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">errList</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errList);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;新增更新操作完成&#x27;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>然后代码整体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//更新单位数据库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 没有数据传入则不添加</span><br>    <span class="hljs-keyword">if</span> (!data || !data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;没有需要更新的东西&#x27;</span>);<br>    <span class="hljs-keyword">const</span> unitList = &#123;&#125;, <span class="hljs-comment">// 单位查询出的线性表</span><br>      idRangeList = []; <span class="hljs-comment">// 限制数据库更新 id 的集合 为准确性</span><br>    <span class="hljs-comment">//查询所有单位</span><br>    <span class="hljs-title function_">getAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (allUnitList) =&gt; &#123;<br>      <span class="hljs-comment">//构建缓存 存储查到的单位信息</span><br>      allUnitList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (unitList[item.<span class="hljs-property">id</span>] = item.<span class="hljs-property">id</span>));<br>      <span class="hljs-comment">// 筛选出待添加和待更新的数据</span><br>      <span class="hljs-keyword">const</span> addList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-keyword">const</span> updateList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-comment">// 以及待更新 id 集合</span><br>      data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>] &amp;&amp; idRangeList.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>));<br><br>      <span class="hljs-comment">// 拼接更新字段的 sql</span><br>      <span class="hljs-keyword">const</span> nameSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> timeSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> delSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> sortSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> totalSql = <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;nameSql&#125;</span> END,sort = CASE _id <span class="hljs-subst">$&#123;sortSql&#125;</span> END,delFlag = CASE _id <span class="hljs-subst">$&#123;delSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;timeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList.join(</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-string">&#x27;,&#x27;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      )&#125;</span>)`</span>;<br><br>      <span class="hljs-keyword">const</span> pTasks = [];<br>      <span class="hljs-keyword">if</span> (addList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">add</span>(addList));<br>      <span class="hljs-keyword">if</span> (updateList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(sqlite.<span class="hljs-title function_">executeSql</span>(totalSql));<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(pTasks)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resList);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">errList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errList);<br>        &#125;)<br>        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;新增更新操作完成&#x27;</span>);<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，好像可以了，但是拼接 SQL 那里用了好多 reduce</p><p>然后开始寻找我遍历 sql 使用超级多 reduce 的解决办法，在知乎上找到了<br><a href="zhihu.com/question/54637225">JavaScript 函数式编程存在性能问题么？</a><br>回答大体是说 JS 不像 haskell 那种惰性求值，所以 JS 的函数式，尤其是链式调用更会造成性能问题，想解决的话可以自己造 Transducers 函数，也就是实现一次遍历，多种操作，翻来翻去，并没有解决我的问题，但是却知道了一个新概念 Transducers  </p><p>遂自闭了十几分钟，想来想去，终于吧思路打开了<br>一次遍历，求多个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 遍历出四条待更新的 sql 语句</span><br><span class="hljs-keyword">const</span> &#123; nameSql, timeSql, delSql, sortSql &#125; = updateList.<span class="hljs-title function_">reduce</span>(<br><span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">nameSql</span>: acc.<span class="hljs-property">nameSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>,<br>  <span class="hljs-attr">timeSql</span>: acc.<span class="hljs-property">timeSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>,<br>  <span class="hljs-attr">delSql</span>: acc.<span class="hljs-property">delSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>,<br>  <span class="hljs-attr">sortSql</span>: acc.<span class="hljs-property">sortSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>,<br>&#125;),<br>&#123;<br>  <span class="hljs-attr">nameSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">timeSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">delSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">sortSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>&#125;,<br>);<br></code></pre></td></tr></table></figure><p>写完后感叹，我懂个屁的 JS  </p><p>然后最终版代码  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 没有数据传入则不添加</span><br>    <span class="hljs-keyword">if</span> (!data || !data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;没有需要更新的东西&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data, <span class="hljs-string">&#x27;待更新数据&#x27;</span>);<br>    <span class="hljs-keyword">const</span> unitList = &#123;&#125;, <span class="hljs-comment">// 单位查询出的线性表</span><br>      idRangeList = []; <span class="hljs-comment">// 限制数据库更新 id 的集合 为准确性</span><br>    <span class="hljs-comment">//查询所有单位</span><br>    <span class="hljs-title function_">getAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (allUnitList) =&gt; &#123;<br>      <span class="hljs-comment">//构建缓存 存储查到的单位信息</span><br>      allUnitList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (unitList[item.<span class="hljs-property">id</span>] = item.<span class="hljs-property">id</span>));<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unitList);<br>      <span class="hljs-comment">// 筛选出待添加和待更新的数据</span><br>      <span class="hljs-keyword">const</span> addList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-keyword">const</span> updateList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-comment">// 以及待更新 id 集合</span><br>      data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>] &amp;&amp; idRangeList.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>));<br><br>      <span class="hljs-comment">// 遍历出四条待更新的 sql 语句</span><br>      <span class="hljs-keyword">const</span> &#123; nameSql, timeSql, delSql, sortSql &#125; = updateList.<span class="hljs-title function_">reduce</span>(<br>        <span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> (&#123;<br>          <span class="hljs-attr">nameSql</span>: acc.<span class="hljs-property">nameSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>,<br>          <span class="hljs-attr">timeSql</span>: acc.<span class="hljs-property">timeSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>,<br>          <span class="hljs-attr">delSql</span>: acc.<span class="hljs-property">delSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>,<br>          <span class="hljs-attr">sortSql</span>: acc.<span class="hljs-property">sortSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>,<br>        &#125;),<br>        &#123;<br>          <span class="hljs-attr">nameSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">timeSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">delSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">sortSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        &#125;,<br>      );<br><br>      <span class="hljs-keyword">const</span> totalSql = <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;nameSql&#125;</span> END,sort = CASE _id <span class="hljs-subst">$&#123;sortSql&#125;</span> END,delFlag = CASE _id <span class="hljs-subst">$&#123;delSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;timeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList.join(</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-string">&#x27;,&#x27;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      )&#125;</span>)`</span>;<br><br>      <span class="hljs-keyword">const</span> pTasks = [];<br>      <span class="hljs-keyword">if</span> (addList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">add</span>(addList));<br>      <span class="hljs-keyword">if</span> (updateList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(sqlite.<span class="hljs-title function_">executeSql</span>(totalSql));<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(pTasks)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resList);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">errList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errList);<br>        &#125;)<br>        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;新增更新操作完成&#x27;</span>);<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>跟之前对比，可读性，可维护性都提高了不少<br>如果追求更好的性能优化，就需要用到 Transducers 的技术，将前面的 filter forEach 都一并处理好<br>但是我个人的观点是  </p><ul><li>业务终查询更新的数据量并不大，最多在 50条 左右，所以现在的代码在可接受范围内</li><li>如果需要维护这段代码，不仅需要读当前逻辑的代码，可能还需要搞懂 Transducers 函数的内容，这样时间成本会增加，所以我选择保持现状</li></ul><p>本文完</p>]]></content>
    
    
    
    <tags>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 年终总结</title>
    <link href="/blog/2022/01/02/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2022/01/02/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="个人方面"><a href="#个人方面" class="headerlink" title="个人方面"></a>个人方面</h3><p>这一年 Blog 内容理应多很多东西的，但是在自己的编程水平提高的同时，边写边删除了大部分的文章  </p><p>被删除的文章标题大致如下  </p><ul><li><p>《nodejs 连接 mysql 实现增删改查》- 刚刚接触用 node 写增删改查的水文  </p></li><li><p>《数组拍平》- 看到 mdn Array 的 flat api，并且用原生写法仿写了一下  </p></li><li><p>《vuex 学习》- 对着官网抄抄用法，记了一堆流水账  </p></li><li><p>《node websocket》- 写了个 websocket 的用法记录  </p></li><li><p>《this》- 对着书上介绍的 this 用法指向抄抄  </p></li></ul><ul><li>《写业务代码要注意的》- 这个还算比较有意思，从 git<br>记录里翻出了这么一段，当时写这个是很多需求都是以前没有做过的（毕竟上家公司只做过表单业务），然后到了这里，面对这些不容易，对我而言陌生的需求，我感觉压力山大，大概入职两个月的时候写了这个东西，现在看来当时真的是有心了，竟然有这种小总结</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-section">### 写业务代码前的思考</span><br><br><span class="hljs-bullet">-</span> 在写一个复杂需求的时候，一定一定要进行一个总体的分析<br><span class="hljs-bullet">    -</span> 需求的分析，这个大需求里面的小需求是什么<br><span class="hljs-bullet">    -</span> 在做每一个需求的时可能会遇到什么技术难点，有没有解决的办法，这里是查阅资料的阶段<br><span class="hljs-bullet">    -</span> 有些需求的实现页没必要想得太复杂，找好相关技术的文档，一步步的看，从 demo 开始，只要这个技术的文档写的没有问题，最后都可以出货<br><span class="hljs-bullet">    -</span> 细节的处理，有一些细节需要自己去考虑，比如对用户使用是否友好，是不是符合用户的实际使用<br><span class="hljs-bullet">-</span> 总之在写代码之前不要盲目，一定要做好前期的规划，想好了，梳理顺了再去进行编写代码，在代码编写的过程中，也要注意代码的质量，风格，规范等，以及遵从软件工程的原则，写出高可读性，高可维护性的代码<br><span class="hljs-bullet">-</span> 改 bug 的时候也要像看开源项目源码一样，从宏观到微观，不然解决问题的思路都是错误的<br></code></pre></td></tr></table></figure><ul><li><p>《重构》- 读了 《重构》这本书后抄了一些书中的代码，假装自己学会了😊  </p></li><li><p>《跟着 jquery 学正则》- 在尝试看 jquery 源代码的时候把正则表达式学习了一下，然而最后对源码的阅读进度在 jquery 的无 new 构建上止步  </p></li><li><p>《前端编译原理 the super tiny compiler》- 第一次接触到前端编译原理，了解到 ast、parser 等概念，记得这个 200 行的小项目我看了三四天  </p></li></ul><p>总之就是，今年写的这种文章，现在回过头看，虽然觉得很水很幼稚，但是在这个过程中，解决问题的能力越来越强了  </p><p>期间读 <a href="https://antfu.me/posts/about-yak-shaving-zh">关于 Yak Shaving</a> 这篇文章给我的启发很大，里面有提到</p><blockquote><p>Yak Shaving 的字面意思是为剪牦牛毛，而引申出来的意思是，当你在进行一个工作时，发现另一个工作还没有完成，你便先去解决那个工作，在进行那个工作时，你又发现另一个工作… 如此往复，让你偏离了原本本该完成的工作，最终却也什么都没有完成。</p></blockquote><p>在其他领域可能这样做会导致没什么成果，但是在编程这个领域，这样做得结果就是在不断学习的过程中，解决问题的能力，各种技能也都会得到提升。</p><h3 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h3><p>今年因为项目一直在维护，确实见识到了什么叫代码的脏乱差<br>也让我的内心更加确定了，编程这东西实力与工作经验完全不是强相关<br>发现了每个人都有自己擅长的东西和不擅长的东西  </p><p>毕业这一年半以来，最明显的就是自己的棱角被磨平了好多，没有了在校时的狂气（指在校期间总觉得就业很简单，结果差点失业），可能这就是社会大学对每个人的磨练吧  </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>给 uniapp 提了一个 pr ，bug 并不难修复，难的是我将项目拉下来并且跑起来，最后定位到 bug 所在的过程。这个调试的过程对我而言是一段痛并快乐的经历</li><li>给 windicss 翻译了 3-4 篇文档，做出了一点贡献，在参与这个项目的过程中，学会了开源的协作方式  </li><li>英语水平有了显著提高，可以较为流畅得阅读一些英文文档，学会了用英文搜索自己遇到的问题（善用英文搜索，利好你我他，大多数问题分分钟解决）  </li></ul><blockquote><p>思考：每每我在英文环境下找到自己问题的答案的时候，就会对国内的互联网环境感到悲哀，这么多年你抄我我抄你，不断的向技术圈排泄各种垃圾<br>一些爬虫甚至都已经爬一些墙外网站然后翻译（机翻）到国内，每次打开这种搜索结果，都会被恶心到  </p></blockquote><h3 id="展望一下-2022"><a href="#展望一下-2022" class="headerlink" title="展望一下 2022"></a>展望一下 2022</h3><p>英语还是要继续学习的，不为别的，就为了能读上第一手英文文档，能对开源社区多做一些贡献  😜  </p><p>日语出于兴趣也会持续学习的 😉</p><p>保持学习，好好生活，热爱生活，少比较，少焦虑，降低期望，提高幸福感，少熬夜，不遗憾过去，展望未来 🤪</p><p>只能这样子加加油，打打气了，不管咋样，生活还是要继续的不是吗 💕💕💕💕</p>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端的 haskell 笔记 ②</title>
    <link href="/blog/2021/12/20/haskell/%E5%89%8D%E7%AB%AF%E7%9A%84-haskell-%E7%AC%94%E8%AE%B0-%E2%91%A1/"/>
    <url>/blog/2021/12/20/haskell/%E5%89%8D%E7%AB%AF%E7%9A%84-haskell-%E7%AC%94%E8%AE%B0-%E2%91%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="haskell-类型"><a href="#haskell-类型" class="headerlink" title="haskell 类型"></a>haskell 类型</h3><p>判断类型的运算符是 <code>:t</code>  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-type">Prelude</span>&gt; :t &#x27;a&#x27;<br>&#x27;a&#x27; :: <span class="hljs-type">Char</span><br><span class="hljs-type">Prelude</span>&gt; :t <span class="hljs-type">True</span><br><span class="hljs-type">True</span> :: <span class="hljs-type">Bool</span><br><span class="hljs-type">Prelude</span>&gt; :t <span class="hljs-number">4</span> == <span class="hljs-number">5</span><br><span class="hljs-number">4</span> == <span class="hljs-number">5</span> :: <span class="hljs-type">Bool</span><br><span class="hljs-type">Prelude</span>&gt; :t (<span class="hljs-type">True</span>,&#x27;a&#x27;,<span class="hljs-string">&quot;123&quot;</span>)<br>(<span class="hljs-type">True</span>,&#x27;a&#x27;,<span class="hljs-string">&quot;123&quot;</span>) :: (<span class="hljs-type">Bool</span>, <span class="hljs-type">Char</span>, [<span class="hljs-type">Char</span>])<br></code></pre></td></tr></table></figure><p>函数的类型是这样子的  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">fn</span> :: [<span class="hljs-type">Char</span>] -&gt; [<span class="hljs-type">Char</span>]<br><span class="hljs-title">fn</span> st = [c | c &lt;- st, c `elem` [&#x27;a&#x27; .. &#x27;z&#x27;]]<br><span class="hljs-comment">-- 终端调用  [Char]与 String 等价，使用 String 会更清晰</span><br>*<span class="hljs-type">Main</span>&gt; fn [&#x27;a&#x27;,&#x27;<span class="hljs-type">Z&#x27;</span>,&#x27;<span class="hljs-type">A&#x27;</span>,&#x27;b&#x27;]<br><span class="hljs-string">&quot;ab&quot;</span><br><br><span class="hljs-comment">-- 多参数函数的类型 其分别定义了前三个参数和返回值类型</span><br><span class="hljs-title">fnx</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span><br><span class="hljs-title">fnx</span> x y z = x + y + z<br>*<span class="hljs-type">Main</span>&gt; fnx <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>常见的类型大体与其他语言相同  <code>Int</code> <code>Integer</code> <code>Float</code> <code>Double</code></p><p>有趣的地方如 head  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-type">Prelude</span>&gt; :t head<br><span class="hljs-title">head</span> :: [a] -&gt; a<br><span class="hljs-comment">-- 凡是类型首字母必然大写，但是这个例子显然不是，这是类型变量，作用大体与泛型类似，不过更加强大</span><br><span class="hljs-type">Prelude</span>&gt; :t fst<br><span class="hljs-title">fst</span> :: (a, b) -&gt; a<br><br></code></pre></td></tr></table></figure><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-type">Prelude</span>&gt; :t (==)<br>(==) :: <span class="hljs-type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="hljs-type">Bool</span><br>=&gt; 符号是类型约束的意思，可比较的类型都要属于 <span class="hljs-type">Eq</span> 类，这里我的理解是比较的参数需要同为 a 类型，然后两个传入参数和返回值<br><br><span class="hljs-comment">-- 可折叠类型 t ,Eq 类 a，返回布尔值，理解的例子如下</span><br><span class="hljs-type">Prelude</span>&gt; :t elem  <br><span class="hljs-title">elem</span> :: (<span class="hljs-type">Foldable</span> t, <span class="hljs-type">Eq</span> a) =&gt; a -&gt; t a -&gt; <span class="hljs-type">Bool</span><br><span class="hljs-type">Prelude</span>&gt; &#x27;a&#x27; `elem` [&#x27;<span class="hljs-type">A&#x27;</span>]<br><span class="hljs-type">False</span><br><span class="hljs-type">Prelude</span>&gt; &#x27;a&#x27; `elem` <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-type">True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端的 haskell 笔记 ①</title>
    <link href="/blog/2021/12/17/haskell/%E5%89%8D%E7%AB%AF%E7%9A%84-haskell-%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2021/12/17/haskell/%E5%89%8D%E7%AB%AF%E7%9A%84-haskell-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文有些语句可能带有翻译腔，其为本人故意为之 </p></blockquote><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>我们假设，已经安装好了 haskell，并且在终端输入了 ghci 这个命令，好，现在可以在终端里面输入 haskell 的语句了</p><p>首先</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-number">2</span> + <span class="hljs-number">15</span><br><span class="hljs-number">49</span> * <span class="hljs-number">100</span> <br><span class="hljs-number">1800</span> - <span class="hljs-number">18</span><br><span class="hljs-number">5</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>首先就是 haskell 的语法，跟我输入的空格按键是没什么关系的  </p><p>基本的符号也与前端 JS 中的加减乘除是一样的，同样，也可以使用小括号来提高运算的优先级  </p><p>值得注意的是 如果运行 5 * -3 会报错，需要对 -3 加括号，才能得到正确的结果 ，但是实际敲代码的时候，看见报错改掉就好了，相信我一定不会多次犯这种错误的</p><p>布尔值，符号与 JS 中不太一样，是由大写字面开头的</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">True</span> || <span class="hljs-type">False</span><br></code></pre></td></tr></table></figure><p>其他逻辑运算符号，结果也与 JS 相同</p><p>但是 非运算 的符号并不是 <code>!</code> 而是 <code>not</code> ,而且使用 <code>not</code> 的时候后面需要跟一个纯纯的布尔值，不像 JS 那样，是一个表达式或者其他任何的东西</p><p>相等运算符，只需要 == 就可以等于 JS 中的 === 而且比 JS 的更加严谨，而且不同类型之间不可以进行比较，不同类型之间的基本运算也会报错，然后其语言中的不等于号是 <code>/=</code></p><h3 id="JS-里没有的函数"><a href="#JS-里没有的函数" class="headerlink" title="JS 里没有的函数"></a>JS 里没有的函数</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">succ</span> <span class="hljs-number">8</span> =&gt; 会输出<span class="hljs-number">9</span> 表示一个数字的后继<br><span class="hljs-title">min</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> =&gt; 取出两者的一个最小值<br><span class="hljs-title">max</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> =&gt; 取出两者的一个最大值<br></code></pre></td></tr></table></figure><p>刚刚说了 haskell 没空格不敏感，但是在调用这些个函数的时候，需要在函数后面加上空格，这样才能正常运行</p><h3 id="第一个函数"><a href="#第一个函数" class="headerlink" title="第一个函数"></a>第一个函数</h3><blockquote><p>一个参数的函数  </p></blockquote><p>定义  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">doubleMe</span> x = x + x<br></code></pre></td></tr></table></figure><p>调用  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">doubleMe</span> <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><p>结果为 18</p><p>我对其函数的理解是 <code>函数声明</code> <code>参数</code> <code>返回值</code>  </p><p>JS 中类似这样  </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">doubleMe</span> = (<span class="hljs-params">x</span>) =&gt; x + x<br></code></pre></td></tr></table></figure><blockquote><p>那两个参数的函数长什么样子呢  </p></blockquote><p>定义  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">doubleUs</span> x y = x * <span class="hljs-number">2</span> + y * <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>调用  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">doubleUs</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>为什么要说 haskell 是纯函数式语言请看  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">doubleUs</span> = doubleMe x + doubleMe y<br></code></pre></td></tr></table></figure><p>看到了吗，函数式的可组合的威力  </p><p>如果是 JS 比较简洁的写法要这样   </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">doubleUs</span> = (<span class="hljs-params">x,y</span>) =&gt; <span class="hljs-title function_">doubleMe</span>(x) + <span class="hljs-title function_">doubleMe</span>(y)<br></code></pre></td></tr></table></figure><p>额。。。。。。貌似也挺简洁的，虽然但是，谁叫 JS 是动态弱类型的语言呢，哼哼~~~  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">doubleSmallNumber</span> x = <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span><br>                        <span class="hljs-keyword">then</span> x<br>                        <span class="hljs-keyword">else</span> x*<span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure><p>haskell 的 if 语句也是作为表达式存在的，而且其 else 语句不可以省略，上面的函数其实大可不必换行，可能这里的换行只是为了看起来清晰一些 ?</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">doubleSmallNumber&#x27;</span> x = (<span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">then</span> x <span class="hljs-keyword">else</span> x * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">joe<span class="hljs-symbol">&#x27;Berden</span> = <span class="hljs-string">&quot;50W&quot;</span><br></code></pre></td></tr></table></figure><p>中间有 <code>&#39;</code> 也是允许的  </p><h4 id="函数名不允许大写开头"><a href="#函数名不允许大写开头" class="headerlink" title="函数名不允许大写开头"></a>函数名不允许大写开头</h4><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>常见的操作</p><p>数组拼接类似于 concat </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hs">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] ++ [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>数组中也只能放同类型的元素</p><p>++ 号还可以拼接字符串  </p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-string">&quot;hello &quot;</span> ++ <span class="hljs-string">&quot;world&quot;</span><br>[&#x27;w&#x27;,&#x27;o&#x27;] ++ [&#x27;o&#x27;,&#x27;t&#x27;] =&gt; <span class="hljs-string">&quot;woot&quot;</span><br></code></pre></td></tr></table></figure><p>++ 操作符号执行的时候会遍历前面的数组或者字符串，所以操作大量数据的时候需要注意一下  </p><p>另一个语法糖 <code>:</code> 在 list 字符串的前面添加一个元素</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Prelude</span>&gt; <span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">3</span>:[]<span class="hljs-meta"></span><br><span class="hljs-meta">[1,2,3]</span><br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Prelude&gt; &#x27;A&#x27;:<span class="hljs-string">&quot; SMALL CAT&quot;</span> <br><span class="hljs-string">&quot;A SMALL CAT&quot;</span><br></code></pre></td></tr></table></figure><p>如果想根据 list 的索引获取元素，使用 !! 符号进行  </p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Prelude&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]!!<span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>Prelude&gt; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]!!<span class="hljs-number">4</span><br>*** Exception: Prelude.!!: index too large<br></code></pre></td></tr></table></figure><p>同样二维数组也是支持的 </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Prelude&gt; let b = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3,4]</span>,<span class="hljs-comment">[5,3,3,3]</span>,<span class="hljs-comment">[1,2,2,3,4]</span>,<span class="hljs-comment">[1,2,3]</span>]</span>   <br>Prelude&gt; b<br><span class="hljs-comment">[<span class="hljs-comment">[1,2,3,4]</span>,<span class="hljs-comment">[5,3,3,3]</span>,<span class="hljs-comment">[1,2,2,3,4]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p>list 支持比较大小，前提是里面元素类型是可比较元素  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Prelude&gt; <span class="hljs-comment">[1,2,3]</span> == <span class="hljs-comment">[1,2,3]</span><br>True<br>Prelude&gt; <span class="hljs-comment">[2,2,3]</span> == <span class="hljs-comment">[1,2,3]</span><br>False<br>Prelude&gt; <span class="hljs-comment">[2,2,3]</span> &gt; <span class="hljs-comment">[1,2,3]</span><br>True<br>Prelude&gt; <span class="hljs-comment">[2,2,3]</span> &gt; <span class="hljs-comment">[1,9,9]</span><br>True   <br></code></pre></td></tr></table></figure><p>其他常见 list 操作  </p><p>取其头部<br><code>head [1,2,3] =&gt; 1</code></p><p>最后一个元素<br><code>last [1,2,3]=&gt;3</code></p><p>去除头部的第一个元素,返回剩余数组（18cm 不含头）<br><code>tail [1,2,3] =&gt; [2,3]</code></p><p>去除尾部返回前面所有，顾头不顾腚<br><code>init [1,2,3]=&gt;[1,2]</code></p><p>数组长度<br><code>length [1,2,3]=&gt;3</code></p><p>空检查 =&gt; boolean<br><code>null [1,2,3]=&gt;False</code><br><code>null []=&gt;True</code></p><p>反转数组<br><code>reverse [5,4,3,2,1]=&gt;[1,2,3,4,5]</code>  </p><p>返回数组前几个元素<br><code>take 2 [1,2,3]=&gt;[1,2]</code>  </p><p>返回数组后几个元素<br><code>drop 2 [1,2,3]=&gt;[2,3]</code>  </p><p>返回数组最大元素<br><code>maximum [1,2,3]=&gt;3</code>  </p><p>返回数组最小元素<br><code>minimum [1,2,3]=&gt;1</code>  </p><p>返回数组元素的和<br><code>sum [1,2,3]=&gt;6</code>  </p><p>返回数组元素的乘积</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">product</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]=&gt;<span class="hljs-number">6</span><br>```  <br>判断元素是否在数组中  <br>```hs<br><span class="hljs-title">elem</span> <span class="hljs-number">3</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]=&gt;<span class="hljs-type">True</span> <br><span class="hljs-title">elem</span> <span class="hljs-number">4</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]=&gt;<span class="hljs-type">False</span><br><span class="hljs-number">3</span> `elem` [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]=&gt;<span class="hljs-type">True</span> <span class="hljs-comment">--缀函数</span><br></code></pre></td></tr></table></figure><p>上面的以缀函数的形式也可  </p><h3 id="list-的语法糖"><a href="#list-的语法糖" class="headerlink" title="list 的语法糖"></a>list 的语法糖</h3><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-type">Prelude</span>&gt; [<span class="hljs-number">1</span>..<span class="hljs-number">20</span>]<br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-type">Prelude</span>&gt; [&#x27;a&#x27;..&#x27;z&#x27;]<br><span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="hljs-type">Prelude</span>&gt; [&#x27;<span class="hljs-type">A&#x27;</span>..&#x27;<span class="hljs-type">F&#x27;</span>]<br><span class="hljs-string">&quot;ABCDEF&quot;</span><br><span class="hljs-type">Prelude</span>&gt; [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>..<span class="hljs-number">20</span>] <br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>haskell 是惰性求值的，只会返回被使用的值</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-title">cycle</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-comment">-- 在控制台中无限循环</span><br><br><span class="hljs-comment">--如果这样会取出自己需要个数的元素</span><br><span class="hljs-type">Prelude</span>&gt; take <span class="hljs-number">10</span> (cycle [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br><br><span class="hljs-type">Prelude</span>&gt; take <span class="hljs-number">12</span> (cycle <span class="hljs-string">&quot;ABC&quot;</span>)<br><span class="hljs-string">&quot;ABCABCABCABC&quot;</span><br></code></pre></td></tr></table></figure><p>你可能注意到了 , haskell 是区分字符串 <code>&quot;&quot;</code> 和单个字符 <code>&#39;&#39;</code> 的符号的  </p><p>repeat 重复一个元素 , 无限循环</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-type">Prelude</span>&gt; take <span class="hljs-number">10</span> (repeat <span class="hljs-number">5</span> )<br>[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>集合写法<br>如例子，就是数学中的集合</p><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-type">Prelude</span>&gt; [x*<span class="hljs-number">2</span> | x&lt;-[<span class="hljs-number">1</span>..<span class="hljs-number">10</span>]]<br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]<br><span class="hljs-comment">--后面添加限制的例子 返回将 x 每一项乘以 2 并且大于 12 的元素的集合</span><br><br><span class="hljs-type">Prelude</span>&gt; [x*<span class="hljs-number">2</span>|x &lt;-[<span class="hljs-number">1</span>..<span class="hljs-number">10</span>],x*<span class="hljs-number">2</span>&gt;=<span class="hljs-number">12</span>]<br>[<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>]<br><br><span class="hljs-comment">--更多限制 用缀函数来筛选 ÷7 余数为 3 的元素</span><br><span class="hljs-type">Prelude</span>&gt; [x|x &lt;-[<span class="hljs-number">50</span>..<span class="hljs-number">100</span>],x `mod` <span class="hljs-number">7</span> == <span class="hljs-number">3</span>]<br>[<span class="hljs-number">52</span>,<span class="hljs-number">59</span>,<span class="hljs-number">66</span>,<span class="hljs-number">73</span>,<span class="hljs-number">80</span>,<span class="hljs-number">87</span>,<span class="hljs-number">94</span>]<br><br><span class="hljs-comment">--骚操作 将其限制为返回一个集合中的偶数 并且根据条件将返回值进行替换</span><br><span class="hljs-type">Prelude</span>&gt; custom_filter xs = [<span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;BOOM!&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;boom!&quot;</span> | x &lt;- xs,odd x] <br><span class="hljs-type">Prelude</span>&gt; custom_filter [<span class="hljs-number">7</span>..<span class="hljs-number">13</span>]<br>[<span class="hljs-string">&quot;BOOM!&quot;</span>,<span class="hljs-string">&quot;BOOM!&quot;</span>,<span class="hljs-string">&quot;boom!&quot;</span>,<span class="hljs-string">&quot;boom!&quot;</span>]<br><br><span class="hljs-comment">-- 多个限制条件 将符合筛选条件的元素返回 这里的 /= 是不等于</span><br><span class="hljs-type">Prelude</span>&gt; [x | x &lt;- [<span class="hljs-number">10</span>..<span class="hljs-number">20</span>], x /= <span class="hljs-number">20</span>,x/=<span class="hljs-number">13</span>]<br>[<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>]<br><br><span class="hljs-comment">-- 多个集合中取元素</span><br><span class="hljs-type">Prelude</span>&gt; [ x*y | x &lt;- [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>], y &lt;- [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]]   <br>[<span class="hljs-number">16</span>,<span class="hljs-number">20</span>,<span class="hljs-number">22</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">55</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>,<span class="hljs-number">110</span>]<br><br><span class="hljs-comment">-- 多个集合取元素 并附加筛选条件</span><br><span class="hljs-type">Prelude</span>&gt; [ x*y | x &lt;- [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>], y &lt;- [<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>], x*y &gt; <span class="hljs-number">50</span>] <br>[<span class="hljs-number">55</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>,<span class="hljs-number">110</span>]<br><br><span class="hljs-comment">-- 灵活 强大 自动排列组合 这让我想起来小学时候将三个字的名字颠倒组合 </span><br><span class="hljs-type">Prelude</span>&gt; <span class="hljs-keyword">let</span> nouns = [<span class="hljs-string">&quot;hobo&quot;</span>,<span class="hljs-string">&quot;frog&quot;</span>,<span class="hljs-string">&quot;pope&quot;</span>]   <br><span class="hljs-type">Prelude</span>&gt; <span class="hljs-keyword">let</span> adjectives = [<span class="hljs-string">&quot;lazy&quot;</span>,<span class="hljs-string">&quot;grouchy&quot;</span>,<span class="hljs-string">&quot;scheming&quot;</span>]   <br><span class="hljs-type">Prelude</span>&gt; [adjective ++ <span class="hljs-string">&quot; &quot;</span> ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]   <br>[<span class="hljs-string">&quot;lazy hobo&quot;</span>,<span class="hljs-string">&quot;lazy frog&quot;</span>,<span class="hljs-string">&quot;lazy pope&quot;</span>,<span class="hljs-string">&quot;grouchy hobo&quot;</span>,<span class="hljs-string">&quot;grouchy frog&quot;</span>,<span class="hljs-string">&quot;grouchy pope&quot;</span>,<span class="hljs-string">&quot;scheming hobo&quot;</span>,<span class="hljs-string">&quot;scheming frog&quot;</span>,<span class="hljs-string">&quot;scheming pope&quot;</span>]  <br></code></pre></td></tr></table></figure><h3 id="length-函数编写"><a href="#length-函数编写" class="headerlink" title="length 函数编写"></a>length 函数编写</h3><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-comment">-- 思路就是将传入数据的每一项都替换为 1，返回这个 list 然后对其进行求和</span><br><span class="hljs-type">Prelude</span>&gt; length&#x27; xs = sum [<span class="hljs-number">1</span> | _ &lt;- xs]<br><span class="hljs-type">Prelude</span>&gt; length&#x27; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果将这个函数用 JS 编写，我是这样实现的，可以看到，hs 这语言太抽象了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">_length</span> = (<span class="hljs-params">arr</span>) =&gt; arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> <span class="hljs-number">1</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>简而言之就是 集合里的参数 <code>[替换条件 | 从那个集合中映射数据 , ...返回 list 的限制条件]</code></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight hs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs hs"><span class="hljs-comment">-- 不同类型的数据的集合</span><br><span class="hljs-type">Prelude</span>&gt; (<span class="hljs-number">123</span>,&#x27;a&#x27;,<span class="hljs-string">&quot;123123&quot;</span>)<br>(<span class="hljs-number">123</span>,&#x27;a&#x27;,<span class="hljs-string">&quot;123123&quot;</span>)<br><br><span class="hljs-comment">-- 返回元组首项</span><br><span class="hljs-type">Prelude</span>&gt; fst (<span class="hljs-number">8</span>,<span class="hljs-number">11</span>)   <br><span class="hljs-number">8</span><br><br><span class="hljs-comment">-- 返回元组尾项</span><br><span class="hljs-type">Prelude</span>&gt; snd (<span class="hljs-number">8</span>,<span class="hljs-number">11</span>)   <br><span class="hljs-number">11</span><br><br><span class="hljs-meta">#### 很 cool 的函数 zip</span><br>```hs<br><span class="hljs-type">Prelude</span>&gt; zip [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]   <br>[(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)]<br><span class="hljs-type">Prelude</span>&gt; zip [<span class="hljs-number">1</span> .. <span class="hljs-number">5</span>] [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>]   <br>[(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;one&quot;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;two&quot;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;three&quot;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;four&quot;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;five&quot;</span>)]<br><span class="hljs-comment">-- 如你所见 其会将两个集合中的元素组合成元组 返回一个 list</span><br></code></pre></td></tr></table></figure><blockquote><p>如文，简简单单的基本语法就先到这里，sayonara！！！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>haskell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-合并两个有序链表</title>
    <link href="/blog/2021/11/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/blog/2021/11/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目-amp-amp-链接"><a href="#题目-amp-amp-链接" class="headerlink" title="题目 &amp;&amp; 链接"></a>题目 &amp;&amp; <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">链接</a></h3><p>将两个升序链表合并为一个新的升序链表。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p>如果将链表类比为数组，这题相当于将两个数组合并，然后从小到大排序 </p><h3 id="过程中遇到的坑"><a href="#过程中遇到的坑" class="headerlink" title="过程中遇到的坑"></a>过程中遇到的坑</h3><p>因为是人生中第一次做链表的题目，所以被示例中的入参的数组形式给忽悠了，以为需要将数组转换为链表然后在进行操作，经过好一番折腾，最终弄懂题意，题目的参数如果用 JS 来表示的话，大概是这样子的结构  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">L1</span> = &#123;<br>  <span class="hljs-attr">val</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">next</span>: &#123;<br>    <span class="hljs-attr">val</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">L2</span> = &#123;<br>  <span class="hljs-attr">val</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">next</span>: &#123;<br>    <span class="hljs-attr">val</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>返回值与其结构也是一模一样的  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解题思路的话就是对比两个链表的各个结点上的 val 值，根据 val 值大小的不同，去改变当前结点 next 所指向的值  </p><ol><li>遍历，一点点对比两个链表每个结点大小，并且慢慢缩小链表的长度，如果有一个链表为空了，将另一个链表连接在另一个自定义的 head 结点上 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span> (<span class="hljs-params">list1, list2</span>) &#123;<br>  <span class="hljs-comment">// 递归到头 停止</span><br>  <span class="hljs-comment">// const head = new</span><br>  <span class="hljs-keyword">const</span> resultLinkList = &#123; <span class="hljs-attr">val</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> &#125;;<br>  <span class="hljs-keyword">let</span> currentNode = resultLinkList;<br>  <span class="hljs-comment">// 一点点缩小链表长度就好 </span><br>  <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>    <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &gt;= list2.<span class="hljs-property">val</span>) &#123;<br>      <span class="hljs-comment">// next 指向小一点的链表</span><br>      currentNode.<span class="hljs-property">next</span> = list2;<br>      currentNode = currentNode.<span class="hljs-property">next</span>;<br>      list2 = list2.<span class="hljs-property">next</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      currentNode.<span class="hljs-property">next</span> = list1;<br>      currentNode = currentNode.<span class="hljs-property">next</span>;<br>      list1 = list1.<span class="hljs-property">next</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (list1) &#123;<br>    currentNode.<span class="hljs-property">next</span> = list1;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (list2) &#123;<br>    currentNode.<span class="hljs-property">next</span> = list2;<br>  &#125;<br>  <span class="hljs-keyword">return</span> resultLinkList.<span class="hljs-property">next</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>通过移动 currentNode 来改变 next 指向，过程中不断缩小链表的长度，当有一个链表为空时，将另一个不为空的链表连接在 currentNode 上，这样就完成了合并两个链表的操作  </li></ol><p>currentNode = currentNode.next;<br>这个原理似乎等同于 c 中的指针  </p><ol><li>递归，既然最终只是要改变 next 指向，那么就可以递归来解决  </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span> (<span class="hljs-params">list1, list2</span>) &#123;<br>  <span class="hljs-comment">// 递归到头 停止</span><br>  <span class="hljs-keyword">if</span> (list1 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>  <span class="hljs-keyword">if</span> (list2 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br><br>  <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &lt; list2.<span class="hljs-property">val</span>) &#123;<br>    list1.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(list1.<span class="hljs-property">next</span>, list2);<br>    <span class="hljs-keyword">return</span> list1;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    list2.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(list1, list2.<span class="hljs-property">next</span>);<br>    <span class="hljs-keyword">return</span> list2;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归也更好理解，将两个结点的值进行比较，小的那一方要将自身的 next 值得指向改变为大的那一方，然后递归进行的传参都是对本身上一个 next 结点的引用，这样循环改变 next 结点的值，最后可以得到和遍历一样的结果 </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JS 中没有指针的概念，实际上这个题也是用对象的引用来模拟指针的行为，感觉有一丝丝 trick🙄,人傻了</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端编译原理 the-super-tiny-compiler</title>
    <link href="/blog/2021/10/04/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86the-super-tiny-compiler/"/>
    <url>/blog/2021/10/04/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86the-super-tiny-compiler/</url>
    
    <content type="html"><![CDATA[<h3 id="时隔四个月的更新"><a href="#时隔四个月的更新" class="headerlink" title="时隔四个月的更新"></a>时隔四个月的更新</h3><p>其实后面的递归步骤只是借助 JS 的引用数据类型特性，模拟了类似 c 语言的指针功能 😐 ,就是简单的传递指针，不断生成类似链表的数据结构，填充数据，最终得到目标代码…而已..已.</p><h3 id="起初"><a href="#起初" class="headerlink" title="起初"></a>起初</h3><p>the-super-tiny-compiler 是 github 上的一个使用 js 编写的编译器，代码注释中称其可能是最小的编译器，可以将 lisp 风格的语言编写为 c 风格的语言   </p><p>这个编译器项目可以说是麻雀虽小，五脏俱全</p><p>但是本人再阅读器源代码的时候，在生成新 ast 的过程中，对其递归过程产生了不解  </p><p>所以从现在开始，要对源代码进行一下分析  </p><p>编译器原理简单来说就是<br>词法分析<br>语法分析（生成 ast）<br>将 oldAst -&gt; newAst<br>最后将产生的 newAst 生成目标语言语法进行输出<br>将 <code>(add 2 (subtract 4 2))</code> 作为输入，得到的 ast 结构如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ast = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>  <span class="hljs-attr">body</span>: [<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CallExpression&quot;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;add&quot;</span>,<br>      <span class="hljs-attr">params</span>: [<br>        &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>          <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CallExpression&quot;</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;subtract&quot;</span>,<br>          <span class="hljs-attr">params</span>: [<br>            &#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>              <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;4&quot;</span>,<br>            &#125;,<br>            &#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>              <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>            &#125;,<br>          ],<br>        &#125;,<br>      ],<br>    &#125;,<br>  ],<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>得到这个结构后，执行了这样一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformer</span>(<span class="hljs-params">ast</span>) &#123;<br>  <span class="hljs-keyword">let</span> newAst = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>    <span class="hljs-attr">body</span>: []<br>  &#125;<br><br>  ast.<span class="hljs-property">_context</span> = newAst.<span class="hljs-property">body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>给 ast 对象下添加了一个新属性，将该属性指向了 newAst 的 body 属性中<br>然后向下执行了 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformer</span>(<span class="hljs-params">ast</span>) &#123;<br>  <span class="hljs-keyword">let</span> newAst = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>    <span class="hljs-attr">body</span>: []<br>  &#125;<br><br><span class="hljs-comment">// 这里改变 ast 的属性就可以之间影响到 newAst </span><br>  ast.<span class="hljs-property">_context</span> = newAst.<span class="hljs-property">body</span><br><br>  <span class="hljs-title function_">traverser</span>(ast, &#123;<br>    <span class="hljs-comment">// 处理数字</span><br>    <span class="hljs-title class_">NumberLiteral</span>: &#123;<br>      <span class="hljs-title function_">enter</span>(<span class="hljs-params">node, parent</span>) &#123;<br>        parent.<span class="hljs-property">_context</span>.<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NumberLiteral&#x27;</span>,<br>          <span class="hljs-attr">value</span>: node.<span class="hljs-property">value</span><br>        &#125;)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 字符串</span><br>    <span class="hljs-title class_">StringLiteral</span>: &#123;<br>      <span class="hljs-title function_">enter</span>(<span class="hljs-params">node, parent</span>) &#123;<br>        parent.<span class="hljs-property">_context</span>.<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;StringLiteral&#x27;</span>,<br>          <span class="hljs-attr">value</span>: node.<span class="hljs-property">value</span>,<br>        &#125;);<br>      &#125;,<br>    &#125;,<br><br>    <span class="hljs-title class_">CallExpression</span>: &#123;<br>      <span class="hljs-title function_">enter</span>(<span class="hljs-params">node, parent</span>) &#123;<br>        <span class="hljs-keyword">let</span> expression = &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,<br>          <span class="hljs-attr">callee</span>: &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,<br>            <span class="hljs-attr">name</span>: node.<span class="hljs-property">name</span><br>          &#125;,<br>          <span class="hljs-attr">arguments</span>: []<br>        &#125;<br><br>        node.<span class="hljs-property">_context</span> = expression.<span class="hljs-property">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (parent.<span class="hljs-property">type</span> !== <span class="hljs-string">&quot;CallExpression&quot;</span>) &#123;<br>          expression = &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ExpressionStatement&#x27;</span>,<span class="hljs-comment">//表达式语句</span><br>            expression<br>          &#125;<br>        &#125;<br><br>        parent.<span class="hljs-property">_context</span>.<span class="hljs-title function_">push</span>(expression)<br>      &#125;<br>    &#125;<br><br><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> newAst<span class="hljs-comment">//返回 newAst</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，newAst 的数据变化只执行了一个 traverser 函数就完成了，函数把刚刚的 ast 当作参数，以及根据不同类型对 newAst 中的 body 复制的行为,</p><p>这个函数的内部是这样子的 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverser</span>(<span class="hljs-params">ast, visitor</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseArray</span>(<span class="hljs-params">array, parent</span>) &#123;<br>    <br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseNode</span>(<span class="hljs-params">node, parent</span>) &#123;<br>    <span class="hljs-comment">// 判断传入进来的 node 有没有对应的属性</span><br>    <span class="hljs-keyword">let</span> methods = visitor[node.<span class="hljs-property">type</span>]<br><br>    <span class="hljs-comment">// 如果有 就给其父节点的 body 赋值进去</span><br>    <span class="hljs-keyword">if</span> (methods &amp;&amp; methods.<span class="hljs-property">enter</span>) &#123;<br>      methods.<span class="hljs-title function_">enter</span>(node, parent)<br>    &#125;<br><br>    <span class="hljs-comment">// 然后再把 visiter 中不包括的属性进行单独处理 </span><br>    <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">type</span>) &#123;<br>      <span class="hljs-comment">// first exec 执行最外层的 遍历 节点下的 body</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Program&quot;</span>:<br>        <span class="hljs-title function_">traverseArray</span>(node.<span class="hljs-property">body</span>, node);<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;CallExpression&quot;</span>:<br>        <span class="hljs-title function_">traverseArray</span>(node.<span class="hljs-property">params</span>, node)<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;NumberLiteral&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;StringLiteral&quot;</span>:<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(node.<span class="hljs-property">type</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">traverseNode</span>(ast, <span class="hljs-literal">null</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行他的时候，主线为 traverser -&gt; traverseNode -&gt;<br>ast 作为 node 参数传入进去，这个函数的执行过程就进行了递归调用<br>第一次执行  methods 为 undefined  然后进入 switch 语句中<br>第一次的 ast type 是 Program 然后就将 ast 的 body 当作参数传递进去，然后 break;掉<br>至此，函数主线已经执行完毕了<br>之后的执行流程则是对 ast.body 进行的一个伪递归或者叫嵌套调用，函数每次根据其传入的 tree 参数，根据表达式，参数，去判断是否生成新的 ast </p><p>值得一提的是，在生成 newAst 的时候<br>有类似这样的语句<br><code> node._context = expression.arguments;</code><br>将传入节点的_context 属性指向当前对象下的某个属性，达到引用的效果，这时，使用 visitor 遍历语法数的时候，不管传入的对象是什么，因为已经在上层构建好了内存地址的引用关系，所以只需要给 parent._context 属性添加只就可以了   </p><p>最后的最后就是将生成的新 ast 生成我们的目标语言，这个没什么好说的，递归生成字符串就好了。</p><p>总结，看似简单的小项目，如果自己去实现，不知到要考虑多少细节，所以说，前端深入之路，任重而道远！</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-寻找峰值</title>
    <link href="/blog/2021/08/16/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <url>/blog/2021/08/16/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找一维数组峰值"><a href="#寻找一维数组峰值" class="headerlink" title="寻找一维数组峰值"></a>寻找一维数组峰值</h3><p>峰值元素是指其值大于左右相邻值的元素。在一维数组中找出这个元素。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li><p>暴力破解，遍历数组每个元素判断其左右两侧元素  </p></li><li><p>优化，每次遍历前只需要判断当前值是不是大于后值就完事，<br>理由是如果能执行到 i 的位置，说明上次条件判断不成立，那么 <code>nums[i]</code> 值肯定是大于 <code>num[i-1]</code>,时间复杂度 <code>O(n)</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 题目来源 https://leetcode-cn.com/problems/find-peak-element/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findPeakElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">const</span> length = nums.<span class="hljs-property">length</span><br>  <span class="hljs-comment">// 如果只有一个元素</span><br>  <span class="hljs-keyword">if</span> (length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 两个元素</span><br>  <span class="hljs-keyword">if</span> (nums[length - <span class="hljs-number">1</span>] &gt; nums[length - <span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> length - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-comment">// 每次遍历前只需要判断当前值是不是大于后值就完事</span><br>    <span class="hljs-comment">// 理由是如果能执行到 i 的位置，说明上次条件判断不成立，那么 nums[i] 值肯定是大于 num[i-1]</span><br>    <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">return</span> i<br>    &#125;<br>  &#125;<br>&#125;;<span class="hljs-comment">// 时间复杂度 O(n)</span><br></code></pre></td></tr></table></figure><ul><li>使用二分法查找，时间复杂度 <code>O(logN)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 每次取两端数值的中间值，对比前后中间值前后元素大小，缩小 left right 的范围，最后确定出索引位置</span><br><span class="hljs-keyword">var</span> findPeakElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>      <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">parseInt</span>((left + right) / <span class="hljs-number">2</span>)<br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>          right = mid<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          left = mid + <span class="hljs-number">1</span><br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="寻找二维数组峰值"><a href="#寻找二维数组峰值" class="headerlink" title="寻找二维数组峰值"></a>寻找二维数组峰值</h3><p>有一个矩阵，找出一个元素，这个元素大于其上下左右元素的值</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><ul><li>暴力破解，遍历数组每个元素判断其上下左右元素，判断是否是峰值元素</li><li>二分法查找，先找出二维数组中间行的峰值元素，然后去判断此元素与其上下元素大小的关系，去缩小峰值元素的范围，最后计算出峰值元素</li></ul><p>需要注意在递归条件执行前需要判断 mid 值的范围不要超过边界</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">peak2D</span> = (<span class="hljs-params">nums, start, end</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(start, end);<br>  <span class="hljs-keyword">const</span> mid =  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((end + start) / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">findPeakElement</span>(nums[mid])<br>  <span class="hljs-keyword">if</span> (mid &gt; <span class="hljs-number">0</span> &amp;&amp; nums[mid][index] &lt; nums[mid - <span class="hljs-number">1</span>][index]) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">peak2D</span>(nums, start, mid)<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> &amp;&amp; nums[mid][index] &lt; nums[mid + <span class="hljs-number">1</span>][index]) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">peak2D</span>(nums, mid, end)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123; mid,index &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-最长回文子串</title>
    <link href="/blog/2021/07/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/blog/2021/07/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="动态规划：思路"><a href="#动态规划：思路" class="headerlink" title="动态规划：思路"></a>动态规划：思路</h3><ul><li>先维护一个二维数组，记录其中为回文串的值</li><li>需要计算的值为字符串起始位置和结束位置，最后返回两个位置之间的字符串</li><li>使用双层 for 循环去遍历第一次标记好的二维数组</li><li>在每次遍历到两个字符相等的时候</li><li>去判断这两个字符串是不是挨着，如果挨着，就可以把字符标记为是回文串</li><li>如果不是，就去判断两个字符左右是不是回文串，如果是回文串，也同样把两字符出现位置的二维数组项标记为回文串</li><li>每次执行完上次过程后，都去改变最大长度和开始位置，最后遍历完成，得到的两个值进行截取就取出了回文串</li></ul><h3 id="代码实现-JavaScript"><a href="#代码实现-JavaScript" class="headerlink" title="代码实现 JavaScript"></a>代码实现 JavaScript</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 采用动态规划</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  <span class="hljs-comment">// 定义二维数组, 辅助找出最长回文串</span><br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(s.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>; m &lt; dp.<span class="hljs-property">length</span>; m++) &#123;<br>    dp[m] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(s.<span class="hljs-property">length</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> begin = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义最长回文串的截取初始位置</span><br>  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;<span class="hljs-comment">//回文串最长子串长度</span><br>  <span class="hljs-comment">/* </span><br><span class="hljs-comment">      第一次双重循环的目的: 是为了将指向同一元素的i,j, 标记为回文子串,</span><br><span class="hljs-comment">      (理由:只有一个元素肯定是回文串)</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (i === j) &#123;<br>        dp[i][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1表示是回文串</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[i][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//其他i和j指向的不是一个元素,暂时标记为不是回文串</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">      第二次双重循环的核心思想: </span><br><span class="hljs-comment">          如果i和j指向的数相等,且i+1到j-1的位置原本就是一个回文子串(即dp[i+1][j-1] === 1)时,</span><br><span class="hljs-comment">          那么i到j的位置的字符串一定是一个回文子串,即dp[i][j] === 1</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-property">length</span>; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>      <span class="hljs-keyword">if</span> ((s[i] == s[j]) &amp;&amp; ((i + <span class="hljs-number">1</span> == j) || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>        dp[i][j] = <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; ((j - i + <span class="hljs-number">1</span>) &gt; maxLength)) &#123;<br>        maxLength = j - i + <span class="hljs-number">1</span>;<br>        begin = i;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substr</span>(begin, maxLength);<br>&#125;;<br></code></pre></td></tr></table></figure><p>做题反思，第一道研究明白的难度为中等的题，看了很久，最后还是打断点才看懂这道题的，做完题之后发现算法题是需要训练的，多多训练才有解题的思路，训练次数多少取决于计算机基础水平，天赋，以及勤奋程度。总结：多练多刷。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
