<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>汉诺塔递归</title>
    <link href="/blog/2023/02/26/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92/"/>
    <url>/blog/2023/02/26/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h3 id="又到了这个问题"><a href="#又到了这个问题" class="headerlink" title="又到了这个问题"></a>又到了这个问题</h3><p>记得在初学 c 语言的时候，看过小甲鱼的视频，讲了基本语法之后，直接上手干了一道题，是汉诺塔递归，对我本人的心里造成了巨大创伤，三根柱子搬来搬去，当时真的无法理解这个递归过程</p><p>后来去知乎上，搜 如何理解汉诺塔的递归（大概两年前）当时记住了一个答案</p><p>在刚刚，自己瞎几把学东西的时候，又遇见了汉诺塔的题，但是本菜鸡还是不会这个，怎么办呢？</p><p>当然是玩一下汉诺塔游戏，后来发现四层以内的汉诺很快就解出来了，到了第五层的时候，我拖着拖着，就乱套了，就是说，我连汉诺塔五层都解不出来（菜哭了</p><p>当然上面提到了，以前看过一个知乎回答，大概是说，多层和两层的方法都是一样的，把最下面的一个，和上面所有的看成两个整体，去当成 n = 2 去解</p><p>那么 n 为 2 时，解法是什么呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[1,0]</span> <span class="hljs-selector-attr">[]</span> <span class="hljs-selector-attr">[]</span><br><span class="hljs-selector-tag">A</span> -&gt; <span class="hljs-selector-tag">B</span><br><span class="hljs-selector-attr">[1]</span> <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[]</span><br><span class="hljs-selector-tag">A</span> -&gt; C<br><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-attr">[0]</span> <span class="hljs-selector-attr">[1]</span><br><span class="hljs-selector-tag">B</span> -&gt; C  <br><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-attr">[]</span> <span class="hljs-selector-attr">[1,0]</span><br></code></pre></td></tr></table></figure><p>常言道，没图说个吧唧，上图就是 n = 2 的解法</p><p>两层是这样子，三层呢？三层的游戏内操作也就是把上面 1，2 层放到中间，然后把 3 放到右侧，再把 1，2 通过 A 中转最后都放到最右侧</p><p>按照上面的思路，我刚刚玩的汉诺是 5 层，那么就把它分为 1-4 和 5 两个部分</p><p>正常搬运两个部分需要什么呢？把 1-4 搬运到中间，把 5 搬运到最右边</p><p>其中一步是 1-4 去中间，想要把 1-4 都搬运到中间，也需要两步，1-3 搬运到右边，4 搬运到中间</p><p>如上，我们又得到了把 1-3 搬运到右边的需求，再次拆解，就是把 1-2 搬运到中间，3 搬运到右边  </p><p>… 把 1 搬运到右边，把 2 搬运到中间（最后一步拆解）</p><p>至此，需求明确，也可以推导出汉诺塔求解的递归过程（推完之后也是成功解出了第 6 层的汉诺塔</p><p>那么怎么用程序来描述其递归过程呢？  </p><p>这里用了我最熟悉的 js 来展示这个递归过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> b = [];<br><span class="hljs-keyword">const</span> c = [];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hanota</span>(<span class="hljs-params">A, B, C</span>) &#123;<br>  <span class="hljs-title function_">move</span>(A.<span class="hljs-property">length</span>, A, B, C);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(A, B, C);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">n, A, B, C</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) &#123;<br>    C.<span class="hljs-title function_">push</span>(A.<span class="hljs-title function_">pop</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">move</span>(n - <span class="hljs-number">1</span>, A, C, B);<br>    C.<span class="hljs-title function_">push</span>(A.<span class="hljs-title function_">pop</span>());<br>    <span class="hljs-title function_">move</span>(n - <span class="hljs-number">1</span>, B, A, C);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">hanota</span>(a, b, c);<br></code></pre></td></tr></table></figure><p>过程上面也解释了，这段代码用了 n = 2 时做例子，其中 </p><pre><code class="js">move(n - 1, A, C, B);C.push(A.pop());move(n - 1, B, A, C);</code></pre><p>就是 n 为 2 时 A -&gt; B ，A -&gt; C，B -&gt; C 的直接过程  </p><p>当 n 增加时，和 n = 2 是一样的，不管 n 为几，按照上面的思路，将盘子分为两个整体去看，再逐步拆解，就可以递归出来了  </p><p>递归是真的挺抽象，以前觉得是一种只可意会，不可言传的技术，现在觉得递归是让程序帮我做事。<br>递归不需要用大脑去跑递归程序，而是想出递归的逻辑，每次循环要执行的相同之处，加上结束条件，去描述一段完整的递归代码。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023 年计划</title>
    <link href="/blog/2023/02/15/2023%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    <url>/blog/2023/02/15/2023%E5%B9%B4%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>互联网寒冬来喽，今年要学习  </p><p>首先把去年没看完的 《vue3 设计与实现》先看完–成果：把 vue 源码撸一遍，造一个真正完整可用的轮子  </p><p>学一门不同于 js 的市场上的实用语言–成果：用该语言写后台程序  </p><p>学 csapp 这本书–成果：尽量多看吧，多了解，多思考  </p><p>自考这东西也要搞起来，毕竟这个纯自学还是会有一定收获的–成果：报考考试，考过  </p><p>把后端那一套服务器相关的东西学会–成果：希望后端下次再说刀客，linux 一大堆东西的时候，我能完全听懂  </p><p>其余夯实 js 的小细节，学习 ts –成果：这个不需要解释，基础不牢，地动山摇  </p><p>贪多嚼不烂，就这些</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>一定要夯实计算机科学的基础知识，虽然我资质尚浅，但是我坚定的认为，是否夯实基础一定会影响我未来发展的天花板  </p><p>关于找工作，尝试在网上写写真正有技术含量的文章，在互联网增加曝光度，或许能让我有那么一点点内推的机会（过不过另说，起码能面试  </p><p>另外，谭光志，霍春阳等超级多业界前辈，都是我的榜样，向他们学习，争取三年之内赶上他们一半强（逃</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2022 年终总结</title>
    <link href="/blog/2023/02/15/22-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2023/02/15/22-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="一篇迟来的年终总结"><a href="#一篇迟来的年终总结" class="headerlink" title="一篇迟来的年终总结"></a>一篇迟来的年终总结</h3><h4 id="学习篇"><a href="#学习篇" class="headerlink" title="学习篇"></a>学习篇</h4><p>今年总归是学习少了，原因是跟同事之间打游戏，打的比较 high  </p><p>毕竟找到了玩游戏的最高配置，就是有朋友一起玩  </p><p>相比较 2021 年，花在代码上的时间，下班修炼自己的时间变得非常少，可以说基本没有  </p><p>中间看了霍春阳写的 《vue3 设计与实现》和 vue 渲染器的系列文章，但是也没看完  </p><p>然后就是一些零零散散的学习了一些 ts 骚操作， git 骚操作，程度到什么样子呢，就是用来工作，绰绰有余的程度  </p><p>再就是对公司的业务也更加熟练了  </p><h4 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h4><p>工作上，虽然自己岗位是前端，但是因为跨端搞安卓，接触到了超级多的 sqlite 操作，写了不少的 sql，程度是把后端同学的逻辑在安卓段里完整的实现了一遍，收获则是完整的理解了公司的业务到底是怎么运作的  </p><p>再就是平时私下里会跟同事聊公司靠什么赚钱，公司各部门之间是怎么沟通等等，久而久之对公司整体运作也有了大概的了解，至于这个有什么用，可能别人问起来的时候，我可以说一说公司是做 xxx，卖 xxx，我的工作就是跟这个相关的，而不是别人一问起来，就只能说，我平时画画页面（虽然就是个画页面的  </p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>我的性格属于那种一旦对什么事情感兴趣就回去疯狂的做，直到干腻了，干烦了，就慢慢不那么热情了，今年游戏玩了几个月之后，突然间就进入了贤者模式，偶尔开一下，上个号，打一把，就这样子</p><p>还好在编程上，我性格的这个特点并不适用，但是自己深切的感受到了现在自己处在舒适区，学的东西够用，对业务也能理清理顺，也就不逼迫自己去学习了  </p><p>下了班还是要继续进步的，我一个臭大专，指不定哪天就失业了，那时候，靠自己手头攒的钱能活多久呢？</p><p>开卷有益（卷自己</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>互联网行业的薪资水平跟个人实力有一定关系，但这个关系只占一小部分，其他的都是市场决定的，市场有需求，需求量大，待遇就会上去，等到市场饱和，薪资待遇也就那样子了  </p><h3 id="时刻保持清醒，不要浮躁，不要飘"><a href="#时刻保持清醒，不要浮躁，不要飘" class="headerlink" title="时刻保持清醒，不要浮躁，不要飘"></a>时刻保持清醒，不要浮躁，不要飘</h3><p>总之，市场决定待遇  </p><p>确实感觉到了互联网的寒冬，愿在这个寒冬先苟活住吧，下篇是 23 年计划</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重学两数之和</title>
    <link href="/blog/2022/04/20/%E9%87%8D%E5%AD%A6%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/blog/2022/04/20/%E9%87%8D%E5%AD%A6%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>记得接触到的第一道算法题就是 twoSum ，至今还记得第一次做抓耳挠腮的恨得牙痒痒都没思路的 那个感觉</p><p>解法：</p><ol><li>暴力解法，没有有什么好说的 ，指的注意的就是 j 从 i + 1 开始，可以一定程度上减少遍历次数，时间复杂度 O(n^2)，空间复杂度 O(1)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 暴力解法</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) &#123;<br>                <span class="hljs-keyword">return</span> [i, j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 优化 内部循环可以使用双指针 内部两个指针一个从前往后找，一个从后往前找</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums: number[], target: number</span>): number[] &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">const</span> x = nums[i]<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &lt;= k; j++, k--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] === target - x) &#123;<br>                <span class="hljs-keyword">return</span> [i, j]<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[k] === target - x) &#123;<br>                <span class="hljs-keyword">return</span> [i, k]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>hash table 解法</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">const</span> length = nums.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(target - nums[i])) &#123;<br>            <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(target - nums[i]), i]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(nums[i], i)<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>hash table 解法是遍历数组时构建 hash 表，然后遍历 hash 表，如果 hash 表中有 target - nums[i] 则返回，否则添加到 hash 表中，时间复杂度 O(n)，空间复杂度 O(n)</p><ol start="3"><li>双指针 + hash 表 解法</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[], target: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>[] &#123;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    <span class="hljs-keyword">const</span> length = nums.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = length - <span class="hljs-number">1</span>; i &lt;= j; i++, j--) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target) <span class="hljs-keyword">return</span> [i, j]<br><br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(target - nums[i])) &#123;<br>            <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(target - nums[i]), i]<br>        &#125;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(target - nums[j])) &#123;<br>            <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(target - nums[j]), j]<br>        &#125;<br>        map.<span class="hljs-title function_">set</span>(nums[i], i)<br>        map.<span class="hljs-title function_">set</span>(nums[j], j)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>外侧 for 循环时从两端向中间遍历，随遍历建立 hash table ，降低了时间复杂度 O(n/2)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅读 vue 源码</title>
    <link href="/blog/2022/04/03/vue%20%E6%BA%90%E7%A0%81/vue-%E6%BA%90%E7%A0%81/"/>
    <url>/blog/2022/04/03/vue%20%E6%BA%90%E7%A0%81/vue-%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/column/c_1503887097446068224">文章写在知乎上了</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次代码优化</title>
    <link href="/blog/2022/01/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <url>/blog/2022/01/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="代码优化记录"><a href="#代码优化记录" class="headerlink" title="代码优化记录"></a>代码优化记录</h3><p>首先先说需求:<br>平台：安卓 app<br>功能：使用 sqlite 将数据存储到移动设备上，数据来源为线上接口  </p><p>需求：  </p><ul><li>第一次从线上接口请求数据，拿到所有数据并存储</li><li>除第一次之外，后面再次调用接口查询数据是否有更新  </li><li>更新的数据分为有新增的数据条目和已存储过的数据更新  </li></ul><h3 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h3><p>第一次新增的数据需求很容易，就是查到所有数据，然后将多条数据合并成一条数据就可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sql = data.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> acc + <span class="hljs-string">`(&#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27;, &#x27;<span class="hljs-subst">$&#123;cur.pid&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;cur.pids&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;time&#125;</span>&#x27;,&#x27;<span class="hljs-subst">$&#123;time&#125;</span>&#x27;),`</span>;<br>    &#125;, <span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><p>然后是更新，更新的代码，我当时的思路是，先查询给的数据，然后找出 待更新的 和 新增的 两个数组，对两个数组进分别操作，执行完毕 over, 嗯，想法是很好，然后代码写出来是这个样子的  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//更新单位数据库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!data || !data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;没有需要更新的东西&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data, <span class="hljs-string">&#x27;待更新数据&#x27;</span>);<br>    <span class="hljs-keyword">let</span> updateNameSql = <span class="hljs-string">``</span>,<br>      updateTimeSql = <span class="hljs-string">``</span>;<br>    <span class="hljs-keyword">const</span> waitAddedList = [];<br>    <span class="hljs-keyword">const</span> unitList = &#123;&#125;,<br>      idRangeList = [];<br>    <span class="hljs-comment">//查询所有单位</span><br>    <span class="hljs-title function_">getAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (allUnitList) =&gt; &#123;<br>      allUnitList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (unitList[item.<span class="hljs-property">id</span>] = item.<span class="hljs-property">id</span>));<br><br>      data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">insertData</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 如果存在数据 拼接更新语句 不存在则拼接新增语句</span><br>        <span class="hljs-keyword">if</span> (unitList[insertData.<span class="hljs-property">id</span>]) &#123;<br>          idRangeList.<span class="hljs-title function_">push</span>(insertData.<span class="hljs-property">id</span>);<br>          updateNameSql += <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;insertData.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;insertData.name&#125;</span>&#x27; `</span>;<br>          updateTimeSql += <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;insertData.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          waitAddedList.<span class="hljs-title function_">push</span>(insertData);<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;查询出来的待添加的数据&#x27;</span>, waitAddedList);<br>        &#125;<br>      &#125;);<br><br>      <span class="hljs-comment">//  有待新增的数据新增</span><br>      <span class="hljs-keyword">if</span> (waitAddedList.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-title function_">add</span>(waitAddedList);<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;更新的时候添加新数据失败了&#x27;</span>, e);<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">//有待更新的数据更新</span><br>      <span class="hljs-keyword">if</span> (idRangeList.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">await</span> sqlite.<span class="hljs-title function_">executeSql</span>(<br>            <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;updateNameSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;updateTimeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList</span></span><br><span class="hljs-subst"><span class="hljs-string">              .join(<span class="hljs-string">&#x27;,&#x27;</span>)</span></span><br><span class="hljs-subst"><span class="hljs-string">              .slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)&#125;</span>)`</span>,<br>          );<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e, <span class="hljs-string">&#x27;更新数据出错&#x27;</span>);<br>        &#125;<br>      &#125;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;添加和更新操作完成!!!!!!&#x27;</span>);<br>    &#125;);<br>  &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当时写完了，我内心 os：这 tm 写的是啥，什么鬼东西，初学者也写不出这样的代码吧，这代码看起来好恶心啊，面条代码也不过如此吧  </p><blockquote><p>《重构》中提到:<br>优化思路是优先提高可读性和可维护性，然后再去考虑性能问题</p></blockquote><p>遵从这个原则，开搞</p><h3 id="第二版代码"><a href="#第二版代码" class="headerlink" title="第二版代码"></a>第二版代码</h3><p>既然可读性要高的话，那高阶函数走起来，函数式搞起来，虽然 js 的函数式不是惰性求值的  </p><p>首先不用 forEach 去取两个待更新的列表，之前 forEach 里的 if else 太丑了，顺带改了个变量名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// data.forEach((insertData) =&gt; &#123;</span><br><span class="hljs-comment">//   // 如果存在数据 拼接更新语句 不存在则拼接新增语句</span><br><span class="hljs-comment">//   if (unitList[insertData.id]) &#123;</span><br><span class="hljs-comment">//     idRangeList.push(insertData.id);</span><br><span class="hljs-comment">//     updateNameSql += `WHEN &#x27;$&#123;insertData.id&#125;&#x27; THEN &#x27;$&#123;insertData.name&#125;&#x27; `;</span><br><span class="hljs-comment">//     updateTimeSql += `WHEN &#x27;$&#123;insertData.id&#125;&#x27; THEN &#x27;$&#123;Date.now()&#125;&#x27; `;</span><br><span class="hljs-comment">//   &#125; else &#123;</span><br><span class="hljs-comment">//     waitAddedList.push(insertData);</span><br><span class="hljs-comment">//     console.error(&#x27;查询出来的待添加的数据&#x27;, waitAddedList);</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><span class="hljs-comment">// 筛选出待添加和待更新的数据</span><br><span class="hljs-keyword">const</span> addList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !unitList[item.<span class="hljs-property">id</span>]);<br><span class="hljs-keyword">const</span> updateList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>]);<br><span class="hljs-comment">// 以及待更新 id 集合</span><br>data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>] &amp;&amp; idRangeList.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>));<br></code></pre></td></tr></table></figure><p>然后是拼接 sql 语句的地方，在我改得时候需求还加了两个新字段  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 拼接更新字段的 sql</span><br><span class="hljs-keyword">const</span> nameSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> timeSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> delSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> sortSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">const</span> totalSql = <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;nameSql&#125;</span> END,sort = CASE _id <span class="hljs-subst">$&#123;sortSql&#125;</span> END,delFlag = CASE _id <span class="hljs-subst">$&#123;delSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;timeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList.join(</span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-string">&#x27;,&#x27;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">)&#125;</span>)`</span>;<br></code></pre></td></tr></table></figure><p>处理完两个列表和 sql 语句之后，执行下面的逻辑，选择了 Promise.allSettled 处理未知数量的 promise，取得其返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  有待新增的数据新增</span><br><span class="hljs-comment">// if (waitAddedList.length) &#123;</span><br><span class="hljs-comment">// try &#123;</span><br><span class="hljs-comment">//   await add(waitAddedList);</span><br><span class="hljs-comment">// &#125; catch (e) &#123;</span><br><span class="hljs-comment">//   console.error(&#x27;更新的时候添加新数据失败了&#x27;, e);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// //有待更新的数据更新</span><br><span class="hljs-comment">// if (idRangeList.length) &#123;</span><br><span class="hljs-comment">// try &#123;</span><br><span class="hljs-comment">//   await sqlite.executeSql(</span><br><span class="hljs-comment">//     `UPDATE unit_info SET name = CASE _id $&#123;updateNameSql&#125; END,updateTime = CASE _id $&#123;updateTimeSql&#125; END WHERE _id in ($&#123;idRangeList</span><br><span class="hljs-comment">//       .join(&#x27;,&#x27;)</span><br><span class="hljs-comment">//       .slice(0, -1)&#125;)`,</span><br><span class="hljs-comment">//   );</span><br><span class="hljs-comment">// &#125; catch (e) &#123;</span><br><span class="hljs-comment">//   console.error(e, &#x27;更新数据出错&#x27;);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> pTasks = [];<br><span class="hljs-keyword">if</span> (addList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">add</span>(addList));<br><span class="hljs-keyword">if</span> (updateList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(sqlite.<span class="hljs-title function_">executeSql</span>(totalSql));<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(pTasks)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resList</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resList);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">errList</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errList);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;新增更新操作完成&#x27;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>然后代码整体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//更新单位数据库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 没有数据传入则不添加</span><br>    <span class="hljs-keyword">if</span> (!data || !data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;没有需要更新的东西&#x27;</span>);<br>    <span class="hljs-keyword">const</span> unitList = &#123;&#125;, <span class="hljs-comment">// 单位查询出的线性表</span><br>      idRangeList = []; <span class="hljs-comment">// 限制数据库更新 id 的集合 为准确性</span><br>    <span class="hljs-comment">//查询所有单位</span><br>    <span class="hljs-title function_">getAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (allUnitList) =&gt; &#123;<br>      <span class="hljs-comment">//构建缓存 存储查到的单位信息</span><br>      allUnitList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (unitList[item.<span class="hljs-property">id</span>] = item.<span class="hljs-property">id</span>));<br>      <span class="hljs-comment">// 筛选出待添加和待更新的数据</span><br>      <span class="hljs-keyword">const</span> addList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-keyword">const</span> updateList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-comment">// 以及待更新 id 集合</span><br>      data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>] &amp;&amp; idRangeList.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>));<br><br>      <span class="hljs-comment">// 拼接更新字段的 sql</span><br>      <span class="hljs-keyword">const</span> nameSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> timeSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> delSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> sortSql = updateList.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>      <span class="hljs-keyword">const</span> totalSql = <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;nameSql&#125;</span> END,sort = CASE _id <span class="hljs-subst">$&#123;sortSql&#125;</span> END,delFlag = CASE _id <span class="hljs-subst">$&#123;delSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;timeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList.join(</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-string">&#x27;,&#x27;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      )&#125;</span>)`</span>;<br><br>      <span class="hljs-keyword">const</span> pTasks = [];<br>      <span class="hljs-keyword">if</span> (addList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">add</span>(addList));<br>      <span class="hljs-keyword">if</span> (updateList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(sqlite.<span class="hljs-title function_">executeSql</span>(totalSql));<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(pTasks)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resList);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">errList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errList);<br>        &#125;)<br>        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;新增更新操作完成&#x27;</span>);<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，好像可以了，但是拼接 SQL 那里用了好多 reduce</p><p>然后开始寻找我遍历 sql 使用超级多 reduce 的解决办法，在知乎上找到了<br><a href="zhihu.com/question/54637225">JavaScript 函数式编程存在性能问题么？</a><br>回答大体是说 JS 不像 haskell 那种惰性求值，所以 JS 的函数式，尤其是链式调用更会造成性能问题，想解决的话可以自己造 Transducers 函数，也就是实现一次遍历，多种操作，翻来翻去，并没有解决我的问题，但是却知道了一个新概念 Transducers  </p><p>遂自闭了十几分钟，想来想去，终于吧思路打开了<br>一次遍历，求多个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 遍历出四条待更新的 sql 语句</span><br><span class="hljs-keyword">const</span> &#123; nameSql, timeSql, delSql, sortSql &#125; = updateList.<span class="hljs-title function_">reduce</span>(<br><span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">nameSql</span>: acc.<span class="hljs-property">nameSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>,<br>  <span class="hljs-attr">timeSql</span>: acc.<span class="hljs-property">timeSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>,<br>  <span class="hljs-attr">delSql</span>: acc.<span class="hljs-property">delSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>,<br>  <span class="hljs-attr">sortSql</span>: acc.<span class="hljs-property">sortSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>,<br>&#125;),<br>&#123;<br>  <span class="hljs-attr">nameSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">timeSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">delSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">sortSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>&#125;,<br>);<br></code></pre></td></tr></table></figure><p>写完后感叹，我懂个屁的 JS  </p><p>然后最终版代码  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 没有数据传入则不添加</span><br>    <span class="hljs-keyword">if</span> (!data || !data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;没有需要更新的东西&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data, <span class="hljs-string">&#x27;待更新数据&#x27;</span>);<br>    <span class="hljs-keyword">const</span> unitList = &#123;&#125;, <span class="hljs-comment">// 单位查询出的线性表</span><br>      idRangeList = []; <span class="hljs-comment">// 限制数据库更新 id 的集合 为准确性</span><br>    <span class="hljs-comment">//查询所有单位</span><br>    <span class="hljs-title function_">getAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">async</span> (allUnitList) =&gt; &#123;<br>      <span class="hljs-comment">//构建缓存 存储查到的单位信息</span><br>      allUnitList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (unitList[item.<span class="hljs-property">id</span>] = item.<span class="hljs-property">id</span>));<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unitList);<br>      <span class="hljs-comment">// 筛选出待添加和待更新的数据</span><br>      <span class="hljs-keyword">const</span> addList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> !unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-keyword">const</span> updateList = data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>]);<br>      <span class="hljs-comment">// 以及待更新 id 集合</span><br>      data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> unitList[item.<span class="hljs-property">id</span>] &amp;&amp; idRangeList.<span class="hljs-title function_">push</span>(item.<span class="hljs-property">id</span>));<br><br>      <span class="hljs-comment">// 遍历出四条待更新的 sql 语句</span><br>      <span class="hljs-keyword">const</span> &#123; nameSql, timeSql, delSql, sortSql &#125; = updateList.<span class="hljs-title function_">reduce</span>(<br>        <span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> (&#123;<br>          <span class="hljs-attr">nameSql</span>: acc.<span class="hljs-property">nameSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.name&#125;</span>&#x27; `</span>,<br>          <span class="hljs-attr">timeSql</span>: acc.<span class="hljs-property">timeSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>&#x27; `</span>,<br>          <span class="hljs-attr">delSql</span>: acc.<span class="hljs-property">delSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.delFlag&#125;</span>&#x27; `</span>,<br>          <span class="hljs-attr">sortSql</span>: acc.<span class="hljs-property">sortSql</span> + <span class="hljs-string">`WHEN &#x27;<span class="hljs-subst">$&#123;cur.id&#125;</span>&#x27; THEN &#x27;<span class="hljs-subst">$&#123;cur.sort&#125;</span>&#x27; `</span>,<br>        &#125;),<br>        &#123;<br>          <span class="hljs-attr">nameSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">timeSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">delSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">sortSql</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        &#125;,<br>      );<br><br>      <span class="hljs-keyword">const</span> totalSql = <span class="hljs-string">`UPDATE unit_info SET name = CASE _id <span class="hljs-subst">$&#123;nameSql&#125;</span> END,sort = CASE _id <span class="hljs-subst">$&#123;sortSql&#125;</span> END,delFlag = CASE _id <span class="hljs-subst">$&#123;delSql&#125;</span> END,updateTime = CASE _id <span class="hljs-subst">$&#123;timeSql&#125;</span> END WHERE _id in (<span class="hljs-subst">$&#123;idRangeList.join(</span></span><br><span class="hljs-subst"><span class="hljs-string">        <span class="hljs-string">&#x27;,&#x27;</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      )&#125;</span>)`</span>;<br><br>      <span class="hljs-keyword">const</span> pTasks = [];<br>      <span class="hljs-keyword">if</span> (addList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">add</span>(addList));<br>      <span class="hljs-keyword">if</span> (updateList.<span class="hljs-property">length</span>) pTasks.<span class="hljs-title function_">push</span>(sqlite.<span class="hljs-title function_">executeSql</span>(totalSql));<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>(pTasks)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resList);<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">errList</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errList);<br>        &#125;)<br>        .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;新增更新操作完成&#x27;</span>);<br>        &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>跟之前对比，可读性，可维护性都提高了不少<br>如果追求更好的性能优化，就需要用到 Transducers 的技术，将前面的 filter forEach 都一并处理好<br>但是我个人的观点是  </p><ul><li>业务终查询更新的数据量并不大，最多在 50条 左右，所以现在的代码在可接受范围内</li><li>如果需要维护这段代码，不仅需要读当前逻辑的代码，可能还需要搞懂 Transducers 函数的内容，这样时间成本会增加，所以我选择保持现状</li></ul><p>本文完</p>]]></content>
    
    
    
    <tags>
      
      <tag>coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 年终总结</title>
    <link href="/blog/2022/01/02/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2022/01/02/2021-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="个人方面"><a href="#个人方面" class="headerlink" title="个人方面"></a>个人方面</h3><p>这一年 Blog 内容理应多很多东西的，但是在自己的编程水平提高的同时，边写边删除了大部分的文章  </p><p>被删除的文章标题大致如下  </p><ul><li><p>《nodejs 连接 mysql 实现增删改查》- 刚刚接触用 node 写增删改查的水文  </p></li><li><p>《数组拍平》- 看到 mdn Array 的 flat api，并且用原生写法仿写了一下  </p></li><li><p>《vuex 学习》- 对着官网抄抄用法，记了一堆流水账  </p></li><li><p>《node websocket》- 写了个 websocket 的用法记录  </p></li><li><p>《this》- 对着书上介绍的 this 用法指向抄抄  </p></li></ul><ul><li>《写业务代码要注意的》- 这个还算比较有意思，从 git<br>记录里翻出了这么一段，当时写这个是很多需求都是以前没有做过的（毕竟上家公司只做过表单业务），然后到了这里，面对这些不容易，对我而言陌生的需求，我感觉压力山大，大概入职两个月的时候写了这个东西，现在看来当时真的是有心了，竟然有这种小总结</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs md"><span class="hljs-section">### 写业务代码前的思考</span><br><br><span class="hljs-bullet">-</span> 在写一个复杂需求的时候，一定一定要进行一个总体的分析<br><span class="hljs-bullet">    -</span> 需求的分析，这个大需求里面的小需求是什么<br><span class="hljs-bullet">    -</span> 在做每一个需求的时可能会遇到什么技术难点，有没有解决的办法，这里是查阅资料的阶段<br><span class="hljs-bullet">    -</span> 有些需求的实现页没必要想得太复杂，找好相关技术的文档，一步步的看，从 demo 开始，只要这个技术的文档写的没有问题，最后都可以出货<br><span class="hljs-bullet">    -</span> 细节的处理，有一些细节需要自己去考虑，比如对用户使用是否友好，是不是符合用户的实际使用<br><span class="hljs-bullet">-</span> 总之在写代码之前不要盲目，一定要做好前期的规划，想好了，梳理顺了再去进行编写代码，在代码编写的过程中，也要注意代码的质量，风格，规范等，以及遵从软件工程的原则，写出高可读性，高可维护性的代码<br><span class="hljs-bullet">-</span> 改 bug 的时候也要像看开源项目源码一样，从宏观到微观，不然解决问题的思路都是错误的<br></code></pre></td></tr></table></figure><ul><li><p>《重构》- 读了 《重构》这本书后抄了一些书中的代码，假装自己学会了😊  </p></li><li><p>《跟着 jquery 学正则》- 在尝试看 jquery 源代码的时候把正则表达式学习了一下，然而最后对源码的阅读进度在 jquery 的无 new 构建上止步  </p></li><li><p>《前端编译原理 the super tiny compiler》- 第一次接触到前端编译原理，了解到 ast、parser 等概念，记得这个 200 行的小项目我看了三四天  </p></li></ul><p>总之就是，今年写的这种文章，现在回过头看，虽然觉得很水很幼稚，但是在这个过程中，解决问题的能力越来越强了  </p><p>期间读 <a href="https://antfu.me/posts/about-yak-shaving-zh">关于 Yak Shaving</a> 这篇文章给我的启发很大，里面有提到</p><blockquote><p>Yak Shaving 的字面意思是为剪牦牛毛，而引申出来的意思是，当你在进行一个工作时，发现另一个工作还没有完成，你便先去解决那个工作，在进行那个工作时，你又发现另一个工作… 如此往复，让你偏离了原本本该完成的工作，最终却也什么都没有完成。</p></blockquote><p>在其他领域可能这样做会导致没什么成果，但是在编程这个领域，这样做得结果就是在不断学习的过程中，解决问题的能力，各种技能也都会得到提升。</p><h3 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h3><p>今年因为项目一直在维护，确实见识到了什么叫代码的脏乱差<br>也让我的内心更加确定了，编程这东西实力与工作经验完全不是强相关<br>发现了每个人都有自己擅长的东西和不擅长的东西  </p><p>毕业这一年半以来，最明显的就是自己的棱角被磨平了好多，没有了在校时的狂气（指在校期间总觉得就业很简单，结果差点失业），可能这就是社会大学对每个人的磨练吧  </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>给 uniapp 提了一个 pr ，bug 并不难修复，难的是我将项目拉下来并且跑起来，最后定位到 bug 所在的过程。这个调试的过程对我而言是一段痛并快乐的经历</li><li>给 windicss 翻译了 3-4 篇文档，做出了一点贡献，在参与这个项目的过程中，学会了开源的协作方式  </li><li>英语水平有了显著提高，可以较为流畅得阅读一些英文文档，学会了用英文搜索自己遇到的问题（善用英文搜索，利好你我他，大多数问题分分钟解决）  </li></ul><blockquote><p>思考：每每我在英文环境下找到自己问题的答案的时候，就会对国内的互联网环境感到悲哀，这么多年你抄我我抄你，不断的向技术圈排泄各种垃圾<br>一些爬虫甚至都已经爬一些墙外网站然后翻译（机翻）到国内，每次打开这种搜索结果，都会被恶心到  </p></blockquote><h3 id="展望一下-2022"><a href="#展望一下-2022" class="headerlink" title="展望一下 2022"></a>展望一下 2022</h3><p>英语还是要继续学习的，不为别的，就为了能读上第一手英文文档，能对开源社区多做一些贡献  😜  </p><p>日语出于兴趣也会持续学习的 😉</p><p>保持学习，好好生活，热爱生活，少比较，少焦虑，降低期望，提高幸福感，少熬夜，不遗憾过去，展望未来 🤪</p><p>只能这样子加加油，打打气了，不管咋样，生活还是要继续的不是吗 💕💕💕💕</p>]]></content>
    
    
    
    <tags>
      
      <tag>年终总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-合并两个有序链表</title>
    <link href="/blog/2021/11/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/blog/2021/11/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目-amp-amp-链接"><a href="#题目-amp-amp-链接" class="headerlink" title="题目 &amp;&amp; 链接"></a>题目 &amp;&amp; <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">链接</a></h3><p>将两个升序链表合并为一个新的升序链表。新链表是通过拼接给定的两个链表的所有节点组成的。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p>如果将链表类比为数组，这题相当于将两个数组合并，然后从小到大排序 </p><h3 id="过程中遇到的坑"><a href="#过程中遇到的坑" class="headerlink" title="过程中遇到的坑"></a>过程中遇到的坑</h3><p>因为是人生中第一次做链表的题目，所以被示例中的入参的数组形式给忽悠了，以为需要将数组转换为链表然后在进行操作，经过好一番折腾，最终弄懂题意，题目的参数如果用 JS 来表示的话，大概是这样子的结构  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">L1</span> = &#123;<br>  <span class="hljs-attr">val</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">next</span>: &#123;<br>    <span class="hljs-attr">val</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">L2</span> = &#123;<br>  <span class="hljs-attr">val</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">next</span>: &#123;<br>    <span class="hljs-attr">val</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>,<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>返回值与其结构也是一模一样的  </p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解题思路的话就是对比两个链表的各个结点上的 val 值，根据 val 值大小的不同，去改变当前结点 next 所指向的值  </p><ol><li>遍历，一点点对比两个链表每个结点大小，并且慢慢缩小链表的长度，如果有一个链表为空了，将另一个链表连接在另一个自定义的 head 结点上 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span> (<span class="hljs-params">list1, list2</span>) &#123;<br>  <span class="hljs-comment">// 递归到头 停止</span><br>  <span class="hljs-comment">// const head = new</span><br>  <span class="hljs-keyword">const</span> resultLinkList = &#123; <span class="hljs-attr">val</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span> &#125;;<br>  <span class="hljs-keyword">let</span> currentNode = resultLinkList;<br>  <span class="hljs-comment">// 一点点缩小链表长度就好 </span><br>  <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>    <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &gt;= list2.<span class="hljs-property">val</span>) &#123;<br>      <span class="hljs-comment">// next 指向小一点的链表</span><br>      currentNode.<span class="hljs-property">next</span> = list2;<br>      currentNode = currentNode.<span class="hljs-property">next</span>;<br>      list2 = list2.<span class="hljs-property">next</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      currentNode.<span class="hljs-property">next</span> = list1;<br>      currentNode = currentNode.<span class="hljs-property">next</span>;<br>      list1 = list1.<span class="hljs-property">next</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (list1) &#123;<br>    currentNode.<span class="hljs-property">next</span> = list1;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (list2) &#123;<br>    currentNode.<span class="hljs-property">next</span> = list2;<br>  &#125;<br>  <span class="hljs-keyword">return</span> resultLinkList.<span class="hljs-property">next</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>通过移动 currentNode 来改变 next 指向，过程中不断缩小链表的长度，当有一个链表为空时，将另一个不为空的链表连接在 currentNode 上，这样就完成了合并两个链表的操作  </li></ol><p>currentNode = currentNode.next;<br>这个原理似乎等同于 c 中的指针  </p><ol><li>递归，既然最终只是要改变 next 指向，那么就可以递归来解决  </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val, next) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">list2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span> (<span class="hljs-params">list1, list2</span>) &#123;<br>  <span class="hljs-comment">// 递归到头 停止</span><br>  <span class="hljs-keyword">if</span> (list1 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;<br>  <span class="hljs-keyword">if</span> (list2 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;<br><br>  <span class="hljs-keyword">if</span> (list1.<span class="hljs-property">val</span> &lt; list2.<span class="hljs-property">val</span>) &#123;<br>    list1.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(list1.<span class="hljs-property">next</span>, list2);<br>    <span class="hljs-keyword">return</span> list1;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    list2.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(list1, list2.<span class="hljs-property">next</span>);<br>    <span class="hljs-keyword">return</span> list2;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归也更好理解，将两个结点的值进行比较，小的那一方要将自身的 next 值得指向改变为大的那一方，然后递归进行的传参都是对本身上一个 next 结点的引用，这样循环改变 next 结点的值，最后可以得到和遍历一样的结果 </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JS 中没有指针的概念，实际上这个题也是用对象的引用来模拟指针的行为，感觉有一丝丝 trick🙄,人傻了</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅浅浅尝编译原理 the-super-tiny-compiler</title>
    <link href="/blog/2021/10/04/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86the-super-tiny-compiler/"/>
    <url>/blog/2021/10/04/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86the-super-tiny-compiler/</url>
    
    <content type="html"><![CDATA[<h3 id="时隔四个月的更新"><a href="#时隔四个月的更新" class="headerlink" title="时隔四个月的更新"></a>时隔四个月的更新</h3><p>其实后面的递归步骤只是借助 JS 的引用数据类型特性，模拟了类似 c 语言的指针功能 😐 ,就是简单的传递指针，不断生成类似链表的数据结构，填充数据，最终得到目标代码…而已..已.</p><h3 id="起初"><a href="#起初" class="headerlink" title="起初"></a>起初</h3><p>the-super-tiny-compiler 是 github 上的一个使用 js 编写的编译器，代码注释中称其可能是最小的编译器，可以将 lisp 风格的语言编写为 c 风格的语言   </p><p>这个编译器项目可以说是麻雀虽小，五脏俱全</p><p>但是本人再阅读器源代码的时候，在生成新 ast 的过程中，对其递归过程产生了不解  </p><p>所以从现在开始，要对源代码进行一下分析  </p><p>编译器原理简单来说就是<br>词法分析<br>语法分析（生成 ast）<br>将 oldAst -&gt; newAst<br>最后将产生的 newAst 生成目标语言语法进行输出<br>将 <code>(add 2 (subtract 4 2))</code> 作为输入，得到的 ast 结构如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ast = &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>  <span class="hljs-attr">body</span>: [<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CallExpression&quot;</span>,<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;add&quot;</span>,<br>      <span class="hljs-attr">params</span>: [<br>        &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>          <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CallExpression&quot;</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;subtract&quot;</span>,<br>          <span class="hljs-attr">params</span>: [<br>            &#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>              <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;4&quot;</span>,<br>            &#125;,<br>            &#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;NumberLiteral&quot;</span>,<br>              <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;2&quot;</span>,<br>            &#125;,<br>          ],<br>        &#125;,<br>      ],<br>    &#125;,<br>  ],<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>得到这个结构后，执行了这样一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformer</span>(<span class="hljs-params">ast</span>) &#123;<br>  <span class="hljs-keyword">let</span> newAst = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>    <span class="hljs-attr">body</span>: []<br>  &#125;<br><br>  ast.<span class="hljs-property">_context</span> = newAst.<span class="hljs-property">body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>给 ast 对象下添加了一个新属性，将该属性指向了 newAst 的 body 属性中<br>然后向下执行了 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformer</span>(<span class="hljs-params">ast</span>) &#123;<br>  <span class="hljs-keyword">let</span> newAst = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Program&quot;</span>,<br>    <span class="hljs-attr">body</span>: []<br>  &#125;<br><br><span class="hljs-comment">// 这里改变 ast 的属性就可以之间影响到 newAst </span><br>  ast.<span class="hljs-property">_context</span> = newAst.<span class="hljs-property">body</span><br><br>  <span class="hljs-title function_">traverser</span>(ast, &#123;<br>    <span class="hljs-comment">// 处理数字</span><br>    <span class="hljs-title class_">NumberLiteral</span>: &#123;<br>      <span class="hljs-title function_">enter</span>(<span class="hljs-params">node, parent</span>) &#123;<br>        parent.<span class="hljs-property">_context</span>.<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;NumberLiteral&#x27;</span>,<br>          <span class="hljs-attr">value</span>: node.<span class="hljs-property">value</span><br>        &#125;)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 字符串</span><br>    <span class="hljs-title class_">StringLiteral</span>: &#123;<br>      <span class="hljs-title function_">enter</span>(<span class="hljs-params">node, parent</span>) &#123;<br>        parent.<span class="hljs-property">_context</span>.<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;StringLiteral&#x27;</span>,<br>          <span class="hljs-attr">value</span>: node.<span class="hljs-property">value</span>,<br>        &#125;);<br>      &#125;,<br>    &#125;,<br><br>    <span class="hljs-title class_">CallExpression</span>: &#123;<br>      <span class="hljs-title function_">enter</span>(<span class="hljs-params">node, parent</span>) &#123;<br>        <span class="hljs-keyword">let</span> expression = &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,<br>          <span class="hljs-attr">callee</span>: &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,<br>            <span class="hljs-attr">name</span>: node.<span class="hljs-property">name</span><br>          &#125;,<br>          <span class="hljs-attr">arguments</span>: []<br>        &#125;<br><br>        node.<span class="hljs-property">_context</span> = expression.<span class="hljs-property">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (parent.<span class="hljs-property">type</span> !== <span class="hljs-string">&quot;CallExpression&quot;</span>) &#123;<br>          expression = &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ExpressionStatement&#x27;</span>,<span class="hljs-comment">//表达式语句</span><br>            expression<br>          &#125;<br>        &#125;<br><br>        parent.<span class="hljs-property">_context</span>.<span class="hljs-title function_">push</span>(expression)<br>      &#125;<br>    &#125;<br><br><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> newAst<span class="hljs-comment">//返回 newAst</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，newAst 的数据变化只执行了一个 traverser 函数就完成了，函数把刚刚的 ast 当作参数，以及根据不同类型对 newAst 中的 body 复制的行为,</p><p>这个函数的内部是这样子的 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverser</span>(<span class="hljs-params">ast, visitor</span>) &#123;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseArray</span>(<span class="hljs-params">array, parent</span>) &#123;<br>    <br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseNode</span>(<span class="hljs-params">node, parent</span>) &#123;<br>    <span class="hljs-comment">// 判断传入进来的 node 有没有对应的属性</span><br>    <span class="hljs-keyword">let</span> methods = visitor[node.<span class="hljs-property">type</span>]<br><br>    <span class="hljs-comment">// 如果有 就给其父节点的 body 赋值进去</span><br>    <span class="hljs-keyword">if</span> (methods &amp;&amp; methods.<span class="hljs-property">enter</span>) &#123;<br>      methods.<span class="hljs-title function_">enter</span>(node, parent)<br>    &#125;<br><br>    <span class="hljs-comment">// 然后再把 visiter 中不包括的属性进行单独处理 </span><br>    <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">type</span>) &#123;<br>      <span class="hljs-comment">// first exec 执行最外层的 遍历 节点下的 body</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Program&quot;</span>:<br>        <span class="hljs-title function_">traverseArray</span>(node.<span class="hljs-property">body</span>, node);<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;CallExpression&quot;</span>:<br>        <span class="hljs-title function_">traverseArray</span>(node.<span class="hljs-property">params</span>, node)<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;NumberLiteral&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;StringLiteral&quot;</span>:<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(node.<span class="hljs-property">type</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">traverseNode</span>(ast, <span class="hljs-literal">null</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行他的时候，主线为 traverser -&gt; traverseNode -&gt;<br>ast 作为 node 参数传入进去，这个函数的执行过程就进行了递归调用<br>第一次执行  methods 为 undefined  然后进入 switch 语句中<br>第一次的 ast type 是 Program 然后就将 ast 的 body 当作参数传递进去，然后 break;掉<br>至此，函数主线已经执行完毕了<br>之后的执行流程则是对 ast.body 进行的一个伪递归或者叫嵌套调用，函数每次根据其传入的 tree 参数，根据表达式，参数，去判断是否生成新的 ast </p><p>值得一提的是，在生成 newAst 的时候<br>有类似这样的语句<br><code> node._context = expression.arguments;</code><br>将传入节点的_context 属性指向当前对象下的某个属性，达到引用的效果，这时，使用 visitor 遍历语法数的时候，不管传入的对象是什么，因为已经在上层构建好了内存地址的引用关系，所以只需要给 parent._context 属性添加只就可以了   </p><p>最后的最后就是将生成的新 ast 生成我们的目标语言，这个没什么好说的，递归生成字符串就好了。</p><p>总结，看似简单的小项目，如果自己去实现，不知到要考虑多少细节，所以说，前端深入之路，任重而道远！</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-寻找峰值</title>
    <link href="/blog/2021/08/16/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <url>/blog/2021/08/16/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="寻找一维数组峰值"><a href="#寻找一维数组峰值" class="headerlink" title="寻找一维数组峰值"></a>寻找一维数组峰值</h3><p>峰值元素是指其值大于左右相邻值的元素。在一维数组中找出这个元素。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li><p>暴力破解，遍历数组每个元素判断其左右两侧元素  </p></li><li><p>优化，每次遍历前只需要判断当前值是不是大于后值就完事，<br>理由是如果能执行到 i 的位置，说明上次条件判断不成立，那么 <code>nums[i]</code> 值肯定是大于 <code>num[i-1]</code>,时间复杂度 <code>O(n)</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 题目来源 https://leetcode-cn.com/problems/find-peak-element/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findPeakElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">const</span> length = nums.<span class="hljs-property">length</span><br>  <span class="hljs-comment">// 如果只有一个元素</span><br>  <span class="hljs-keyword">if</span> (length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 两个元素</span><br>  <span class="hljs-keyword">if</span> (nums[length - <span class="hljs-number">1</span>] &gt; nums[length - <span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span> length - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-comment">// 每次遍历前只需要判断当前值是不是大于后值就完事</span><br>    <span class="hljs-comment">// 理由是如果能执行到 i 的位置，说明上次条件判断不成立，那么 nums[i] 值肯定是大于 num[i-1]</span><br>    <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">return</span> i<br>    &#125;<br>  &#125;<br>&#125;;<span class="hljs-comment">// 时间复杂度 O(n)</span><br></code></pre></td></tr></table></figure><ul><li>使用二分法查找，时间复杂度 <code>O(logN)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 每次取两端数值的中间值，对比前后中间值前后元素大小，缩小 left right 的范围，最后确定出索引位置</span><br><span class="hljs-keyword">var</span> findPeakElement = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) &#123;<br>  <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>      <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">parseInt</span>((left + right) / <span class="hljs-number">2</span>)<br>      <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>          right = mid<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          left = mid + <span class="hljs-number">1</span><br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> left<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="寻找二维数组峰值"><a href="#寻找二维数组峰值" class="headerlink" title="寻找二维数组峰值"></a>寻找二维数组峰值</h3><p>有一个矩阵，找出一个元素，这个元素大于其上下左右元素的值</p><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><ul><li>暴力破解，遍历数组每个元素判断其上下左右元素，判断是否是峰值元素</li><li>二分法查找，先找出二维数组中间行的峰值元素，然后去判断此元素与其上下元素大小的关系，去缩小峰值元素的范围，最后计算出峰值元素</li></ul><p>需要注意在递归条件执行前需要判断 mid 值的范围不要超过边界</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">peak2D</span> = (<span class="hljs-params">nums, start, end</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(start, end);<br>  <span class="hljs-keyword">const</span> mid =  <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((end + start) / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">findPeakElement</span>(nums[mid])<br>  <span class="hljs-keyword">if</span> (mid &gt; <span class="hljs-number">0</span> &amp;&amp; nums[mid][index] &lt; nums[mid - <span class="hljs-number">1</span>][index]) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">peak2D</span>(nums, start, mid)<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid &lt; nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> &amp;&amp; nums[mid][index] &lt; nums[mid + <span class="hljs-number">1</span>][index]) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">peak2D</span>(nums, mid, end)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123; mid,index &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-最长回文子串</title>
    <link href="/blog/2021/07/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/blog/2021/07/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="动态规划：思路"><a href="#动态规划：思路" class="headerlink" title="动态规划：思路"></a>动态规划：思路</h3><ul><li>先维护一个二维数组，记录其中为回文串的值</li><li>需要计算的值为字符串起始位置和结束位置，最后返回两个位置之间的字符串</li><li>使用双层 for 循环去遍历第一次标记好的二维数组</li><li>在每次遍历到两个字符相等的时候</li><li>去判断这两个字符串是不是挨着，如果挨着，就可以把字符标记为是回文串</li><li>如果不是，就去判断两个字符左右是不是回文串，如果是回文串，也同样把两字符出现位置的二维数组项标记为回文串</li><li>每次执行完上次过程后，都去改变最大长度和开始位置，最后遍历完成，得到的两个值进行截取就取出了回文串</li></ul><h3 id="代码实现-JavaScript"><a href="#代码实现-JavaScript" class="headerlink" title="代码实现 JavaScript"></a>代码实现 JavaScript</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">string</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 采用动态规划</span><br><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br>  <span class="hljs-comment">// 定义二维数组, 辅助找出最长回文串</span><br>  <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(s.<span class="hljs-property">length</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>; m &lt; dp.<span class="hljs-property">length</span>; m++) &#123;<br>    dp[m] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(s.<span class="hljs-property">length</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> begin = <span class="hljs-number">0</span>;<span class="hljs-comment">//定义最长回文串的截取初始位置</span><br>  <span class="hljs-keyword">let</span> maxLength = <span class="hljs-number">1</span>;<span class="hljs-comment">//回文串最长子串长度</span><br>  <span class="hljs-comment">/* </span><br><span class="hljs-comment">      第一次双重循环的目的: 是为了将指向同一元素的i,j, 标记为回文子串,</span><br><span class="hljs-comment">      (理由:只有一个元素肯定是回文串)</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (i === j) &#123;<br>        dp[i][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1表示是回文串</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[i][j] = <span class="hljs-number">0</span>;<span class="hljs-comment">//其他i和j指向的不是一个元素,暂时标记为不是回文串</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">      第二次双重循环的核心思想: </span><br><span class="hljs-comment">          如果i和j指向的数相等,且i+1到j-1的位置原本就是一个回文子串(即dp[i+1][j-1] === 1)时,</span><br><span class="hljs-comment">          那么i到j的位置的字符串一定是一个回文子串,即dp[i][j] === 1</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-property">length</span>; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>      <span class="hljs-keyword">if</span> ((s[i] == s[j]) &amp;&amp; ((i + <span class="hljs-number">1</span> == j) || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])) &#123;<br>        dp[i][j] = <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; ((j - i + <span class="hljs-number">1</span>) &gt; maxLength)) &#123;<br>        maxLength = j - i + <span class="hljs-number">1</span>;<br>        begin = i;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substr</span>(begin, maxLength);<br>&#125;;<br></code></pre></td></tr></table></figure><p>做题反思，第一道研究明白的难度为中等的题，看了很久，最后还是打断点才看懂这道题的，做完题之后发现算法题是需要训练的，多多训练才有解题的思路，训练次数多少取决于计算机基础水平，天赋，以及勤奋程度。总结：多练多刷。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
